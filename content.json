{"meta":{"title":"Jess2's Blog","subtitle":"제씨의 기술블로그","description":null,"author":"Soyeon Jung","url":"https://jess2.github.io"},"pages":[],"posts":[{"title":"[JS] 호이스팅(Hoisting)","slug":"JS-호이스팅-Hoisting","date":"2018-05-15T15:43:24.000Z","updated":"2018-05-15T16:12:59.346Z","comments":true,"path":"2018/05/16/JS-호이스팅-Hoisting/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-호이스팅-Hoisting/","excerpt":"","text":"자바스크립트의 호이스팅(Hoisting)Hoisting이란, 선언을 현재 스크립트 또는 현재 함수의 맨 위로 이동시키는 JavaScript의 기본 동작이다. 만약, 변수가 함수 내에서 정의되었을 경우 선언이 함수 내부의 최상위로 호이스팅되고, 함수 밖에 정의되었을 경우에는 선언이 전역 컨텍스트의 최상위로 호이스팅 된다. 호이스팅 때문에 변수를 선언하기 전에 사용할 수 있다. JavaScript에서는 변수를 선언하기 전에 사용할 수 있다. 아래에 선언을 해도 선언한 것이 Hoisting 되어 위로 끌어올려지기 때문이다. 아래의 Code-1과 Code-2는 동일한 코드라고 보면 된다. Code-1123456x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 var x; // x 선언 Code-212345var x; // x 선언x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 할당은 호이스팅하지 않고, 선언만 호이스팅한다.JavaScript는 Hoisting을 할 때, 선언만 Hoisting하고, 할당은 Hoisting을 하지 않는다. 다음 Code-3과 Code-4는 동일한 코드라고 보면 된다. Code-3123456var x = 5; // x를 선언하고 x에 5를 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined var y = 7; // y를 선언하고 y에 7을 할당 Code-41234567var x = 5; // x를 선언하고 x에 5를 할당var y; // y를 선언 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined y = 7; // y에 7을 할당 위의 Code-3과 Code-4에서 y에 할당된 값인 7이 출력되지 않고 undefined가 출력되는 이유는, 선언만 위쪽으로 끌어 올려지고(Hoisting), 할당은 위로 끌어 올려지지 않기 때문이다. hosting으로 인해 y는 사용되기 전에 선언은 되었지만, 할당이 수행되지 않았기 때문에 y값은 undefined가 되는 것이다. Hosting은 많은 개발자에게 알려지지 않거나 간과 된 JavaScript의 동작인데, 개발자가 Hosting을 이해하지 못하면 프로그램에 버그가 있을 수 있다. 따라서, 버그를 피하려면 항상 모든 범위의 시작 부분에 모든 변수를 선언하고 할당해야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] onclick과 addEventListener 비교","slug":"JS-onclick과-addEventListener-비교","date":"2018-05-15T14:27:19.000Z","updated":"2018-05-15T15:44:10.976Z","comments":true,"path":"2018/05/15/JS-onclick과-addEventListener-비교/","link":"","permalink":"https://jess2.github.io/2018/05/15/JS-onclick과-addEventListener-비교/","excerpt":"","text":"onclick과 addEventListener 비교자바스크립트에서 클릭 이벤트를 줄 때 어떤 방식을 사용하는가?onclick을 사용할 수도, addEventListener를 사용할 수도 있지만, 어떤 것을 사용하든 이 두 가지가 서로 어떻게 다른 지 알고 있어야 한다. onclick은 하나만, addEventListener는 여러 개를. onclick에는 하나의 콜백만 지정할 수 있지만, addEventListener를 사용하면 여러 개의 이벤트 리스너를 추가할 수 있다. 따라서 만약 onclick 이벤트 핸들러를 두 번 이상 사용한다면, 기존 이벤트 핸들러를 덮어쓰기 때문에 가장 아래에 추가한 핸들러만 제대로 작동한다. 반면, addEventListener는 기존 이벤트 핸들러를 덮어 쓰지 않고 얼마든지 계속해서 핸들러를 추가해도 모든 핸들러가 정상적으로 작동한다. 아래의 코드를 보자. ExampleSee the Pen onclick과 addEventListener 비교 by SoyeonJung (@je_ss2) on CodePen. btn에 onclick과 addEventListener 이벤트 핸들러를 각각 두 개씩, 총 네 개의 핸들러를 만들었지만, alert(&#39;onclick-1&#39;)는 실행되지 않고 나머지 세 개만 실행되는 것을 확인할 수 있다. 그럼 onclick은 왜 있는거야?이쯤 되면 이런 의문이 들 수 있다. 클릭 이벤트를 주고 싶으면 그냥 addEventListener를 사용하면 되지, onclick은 굳이 왜 만든 것일까? onclick은 초기 DOM Level-0에서 제공하던 기능이고, 그 이후 버전인 Level-2에서 추가된 것이 addEventListener이다. addEventListener는 이벤트 캡쳐링, 버블링 같은 이벤트 방식을 설정할 수 있기 때문에 이벤트 제어에 있어서 더욱 유용하지만, addEventListener는 IE8 이하에서는 작동을 하지 않는다. 그래서 구형 브라우저 지원이 필요하면 onclick을 사용하거나 다른 방법을 찾아야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]}]}