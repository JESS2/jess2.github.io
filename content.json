{"meta":{"title":"Jess2's Blog","subtitle":"제씨의 기술블로그","description":null,"author":"Soyeon Jung","url":"https://jess2.github.io"},"pages":[],"posts":[{"title":"[JS] this","slug":"JS-this","date":"2018-05-24T11:59:53.000Z","updated":"2018-05-24T12:16:44.957Z","comments":true,"path":"2018/05/24/JS-this/","link":"","permalink":"https://jess2.github.io/2018/05/24/JS-this/","excerpt":"","text":"this자바스크립트에서의 this는 함수의 현재 실행 문맥이다. 함수 실행에서의 this함수 실행에서의 this는 전역 객체다. 전역 객체는 실행 환경에 따라 결정되는데, 웹 브라우저에서는 window가 전역 객체다. 아래의 예시를 보자. 12345678910function sum(a, b) &#123; document.write(this === window); // true this.myNumber = 20; return a + b;&#125; var obj = sum(15, 16); document.write(obj); // 31document.write(obj.myNumber); // undefineddocument.write(window.myNumber); // 20 7행에서 sum함수를 호출한 결과를 obj라는 변수에 넣었다. sum함수의 매개변수로 15와 16을 전달했고, 1행의 sum함수가 실행된다. 이 때, 7행에서 sum함수를 호출할 때의 this는 전역 객체인 window이므로 2행에서 this === window의 결과는 true이다. 그 후, 3행에서 window객체의 myNumber에 20을 저장한 뒤, 4행에서 15와 16을 더하여 반환한다. 그 반환 값은 7행의 obj에 저장되기 때문에, 8행의 결과는 31이다. 그리고 9행의 obj.myNumber은 정의한 적이 없기 때문에 undefined이며, 10행의 window.myNumber은 아까 3행에서 20으로 저장했기 때문에 20을 출력한다. 그렇다면 이번엔 다음 예제를 보자. 123456789function sum(a, b) &#123; document.write(this === window); // false this.myNumber = 20; return a + b;&#125;var obj = new sum(15, 16); document.write(obj); // [object Object]document.write(obj.myNumber); // 20document.write(window.myNumber); // undefined 이번엔 sum형 객체로 obj를 생성했다. 객체를 생성했을 때의 this는 그 객체 자신이 되기 때문에 2행에서의 this는 obj이다. 따라서 this === window의 값은 false이다. 3행에서 this.myNumber은 obj.myNumber을 의미하기 때문에 obj.myNumber에 20을 저장한다. 그리고 obj는 객체이기 때문에 7행에서 obj의 출력 결과는 [object Object]이다. 8행의 실행 결과는 아까 저장한대로 20이며, window.myNumber은 정의한 적이 없기 때문에 undefined이다. 엄격 모드 함수 실행에서의 this엄격 모드에서 함수 실행에서의 this는 undefined이다. 그리고, 엄격 모드는 현재 스코프 뿐만 아니라 내부 스코프에서도 적용된다. 123456789function sum(a, b) &#123; 'use strict'; // 엄격 모드 document.write(this === window); // false document.write(this === undefined); // true return a + b;&#125; var num = sum(2, 5);document.write(num); // 7 내부 함수에서의 this내부 함수의 문맥은 외부 함수의 문맥에 의존되는 게 아니라 오로지 실행 환경에 좌우된다. 아래의 예시를 보자. 12345678910111213141516var numbers = &#123; numA: 5, numB: 10, sum: function() &#123; document.write(this === numbers); // true function calc() &#123; document.write(this === numbers); // false document.write(this === window); // true return this.numA + this.numB; &#125; return calc(); &#125;&#125;; var result = numbers.sum();document.write(result); // NaN numbers.sum()은 객체 내에 있는 메소드를 실행하는 것이기 때문에 sum메소드 내의 문맥은 numbers객체다. 즉, 5행에서 외부 함수의 this는 numbers인 것이다. 하지만 calc함수는 sum함수 내부에 정의되었다. 이 때 this는 window이다. 또한 이 때 9행에서 this가 window이기 때문에 16행의 출력결과는 NaN이 되는 것이다. 이러한 문제를 해결하기 위해서 calc함수도 sum메소드와 동일한 문맥 상에 있어야 한다. 그래야 numA와 numB속성에 접근할 수 있기 때문이다. 이를 해결하려면 call이나 apply또는 bind를 사용하면 된다. 여기서는 call메소드를 사용하여 해결해보겠다. 12345678910111213141516var numbers = &#123; numA: 5, numB: 10, sum: function() &#123; document.write(this === numbers); // true function calc() &#123; document.write(this === numbers); // true document.write(this === window); // false return this.numA + this.numB; &#125; return calc.call(this); &#125;&#125;; var result = numbers.sum();document.write(result); // 15 11행의 this는 외부 함수인 sum메소드에 속하기 때문에 numbers이다. 따라서 calc.call(this)는 numbers객체에 calc라는 메소드를 등록해주는 셈이기 때문에, calc메소드의 this도 numbers가 된다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] Ajax와 XML / JSON","slug":"JS-ajax와-xml-json","date":"2018-05-24T11:05:27.000Z","updated":"2018-05-24T11:35:30.801Z","comments":true,"path":"2018/05/24/JS-ajax와-xml-json/","link":"","permalink":"https://jess2.github.io/2018/05/24/JS-ajax와-xml-json/","excerpt":"","text":"Ajax와 XML / JSONAjax (Asynchronous JavaScript and XML)Ajax는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 보통 브라우저에서 웹페이지를 요청하면 서버와 통신하여 화면을 refresh하는데, Ajax를 이용하여, 서버로부터 웹 페이지가 반환될 때 화면 전체를 refresh하지 않고, 일부만을 갱신할 수 있게 해준다. 이와 같은 효과로 인해, 페이지 전체를 로드하여 렌더링할 필요가 없어지며, 갱신이 필요한 일부만 로드하여 갱신하면 되므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. 특히 jQuery라이브러리로 Ajax를 사용하면 자바스크립트로만 처리하는 것에 비해 간결해지고 크로스 브라우징 문제도 해결된다. Ajax는 비동기적으로 서버와 브라우저가 데이터를 주고 받는데, 이 때 사용하는 API가 XMLHttpRequest이다. 그렇다고 꼭 XML만을 사용해서 통신해야 하는 것은 아니다. 사실 XML보다는 JSON을 더 많이 사용한다. 데이터 전송 형식 - XML / JSON서버와 클라이언트 또는 애플리케이션에서 처리할 데이터를 주고받을 때 쓰는 자료 형식 중 대표적인 것으로는 XML과 JSON이 있다. XMLHTML과 같이 태그 구조의 형식으로 데이터를 표현한다. XML문법 특성상 데이터 이외에 열고 닫는 태그가 반드시 필요하기 때문에 구조가 복잡해지고 용량이 커지는 것이 단점이다. XML Example123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;books&gt; &lt;book&gt; &lt;title&gt;자바스크립트&lt;/title&gt; &lt;author&gt;Jessie&lt;/author&gt; &lt;price&gt;20000&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;알고리즘&lt;/title&gt; &lt;author&gt;cokk&lt;/author&gt; &lt;price&gt;15000&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;자료구조&lt;/title&gt; &lt;author&gt;ellie&lt;/author&gt; &lt;price&gt;18000&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; $.ajax() 메소드서버에 지정한 형식의 자료를 요청하는 제이쿼리 범용 메소드이다. XML, JSON 등 다양한 타입의 자료를 요청할 수 있다. $.ajax() 메소드 형식12345678$.ajax(&#123; url: '가져올 파일명', dataType: '데이터 형식', success: function() &#123; //콜백 함수(가져온 파일에 대한 처리) ... &#125;&#125;); Example - ajax() 메소드로 xml 문서 불러오기12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; $(function()&#123; $.ajax(&#123; url: 'book.xml', dataType: 'xml', success: function(data)&#123; $(data).find('book').each(function()&#123; var title = $('title', this).text(); var author = $('author', this).text(); var price = $('price', this).text(); var txt = \"&lt;li&gt;\" + title + \", \" + author + \", \" + price + \"&lt;/li&gt;&lt;hr&gt;\"; $('body').append(txt); &#125;); &#125; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; (줄 10) : 불러올 파일의 경로를 지정. (줄 11) : 불러올 파일의 형식을 지정. xml형식의 파일을 불러온다. (줄 12) : 파일을 불러오는 데 성공하면 콜백 함수를 처리한다. 콜백 함수 내부에서는 xml데이터를 불러와서 항목별로 표시하기 위해 각각의 변수에 할당하는 작업을 했다. (줄 13) : $(data)는 $.ajax()메소드가 book.xml파일에서 불러온 데이터 객체다. find()메소드로 하위 book객체를 찾아서 작성된 book객체만큼 each()를 반복 수행한다. (줄 14) : this는 현재 book객체를 의미하고, title은 book객체 안의 title객체를 선택한다는 의미이다. 선택한 객체의 내용을 title변수에 대입한 것이며 나머지 author과 price도 같은 형태로 지정한다. JSONJSON(JavaScript Object Notation)은 자바스크립트 객체 데이터 형식으로, XML데이터 형식에 비해 구조 정의의 용이성과 가독성이 뛰어나서 AJAX의 표준으로 사용된다. JSON Example123456789&#123; \"student\": &#123; \"이름\": \"Jessie\", \"성별\": \"여\", \"주소\": \"경기도 용인시 수지구\", \"취미\": \"프로그래밍\", \"별명\": \"제씨\" &#125;&#125; $.getJSON() 메소드제이쿼리 getJSON()메소드는 ajax()메소드의 축약형으로, JSON데이터에 특화되어 있다. $.getJSON() 메소드 형식1$.getJSON(url, 콜백함수); Example - getJSON() 메소드로 JSON 문서 불러오기12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; $(function()&#123; //json 파일을 data로 가져옴 $.getJSON('book.json', function()&#123; //data 객체 지정 var books = data.book; //데이터 순회 $(books).each(function(i, obj)&#123; var title = obj.title; var author = obj.author; var price = obj.price; var txt = \"&lt;li&gt;\" + title + \", \" + author + \", \" + price + \"&lt;/li&gt;&lt;hr&gt;\"; $('body').append(txt); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; (줄 12) : data객체는 json()에서 불러온 데이터이다. data객체의 book객체를 지정해 변수 book에 대입한다. (줄 14) : each()메소드로 book객체에 포함된 내부 속성 값을 읽어와 출력한다. i는 book객체의 배열 index값이고, obj는 book객체를 의미한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] bind","slug":"JS-bind","date":"2018-05-24T10:45:01.000Z","updated":"2018-05-24T11:21:53.129Z","comments":true,"path":"2018/05/24/JS-bind/","link":"","permalink":"https://jess2.github.io/2018/05/24/JS-bind/","excerpt":"","text":"bindFunction객체에서 기본적으로 가지고 있는 메소드 중 call, apply, bind를 많이 사용하는데 이 세 가지의 차이점을 알아보자. 우선 call과 apply는 함수를 즉시 호출하고 컨텍스트를 수정할 때 사용된다.(call과 apply에 대해 자세히 알아보기) 그러나 bind는 해당 함수를 나중에 이벤트에서 유용한 특정 컨텍스트로 호출할 때 사용된다. 정리하면, call과 apply는 즉시 함수를 호출하지만 bind는 나중에 실행될 때 함수를 호출하기 위한 올바른 컨텍스트를 갖게되는 함수를 반환한다. bind를 사용하여 비동기 콜백 및 이벤트에서 컨텍스트를 유지 관리할 수 있고, 특정 함수에 대해 원본 함수와 동일한 본문을 갖는 바인딩된 함수를 만든다. 다음 예제를 보자. Example12345678910111213141516function Button(content) &#123; this.content = content;&#125;; Button.prototype.click = function() &#123; document.write(this.content + ' clicked');&#125;; var myButton = new Button('OK');myButton.click(); // OK clicked var looseClick = myButton.click;looseClick(); // undefined clicked var boundClick = myButton.click.bind(myButton);boundClick(); // OK clicked 9행에서 Button형 객체인 myButton를 만들었고, 인자 값은 OK이다. 이 때, 10행과 같이 myButton.click()을 실행하면, 프로토타입 체인에 의해서 OK clicked가 정상적으로 출력이 된다. 하지만 12행에서는 myButton.click을 looseClick에 담고, 13행에서 looseClick()을 실행했다. 그러나 이렇게 하면, 12행에서 이미 click 함수가 종료되었기 때문에 13행에서는 this.content를 찾을 수 없게 되어 undefined가 뜬다. bind 메소드는 이와 같은 문제를 해결해준다. bind 메소드는 특정 함수에 대해 원본 함수와 동일한 본문을 갖는 바인딩된 함수를 만들기 때문에, 16행에서 boundClick()을 실행하면 정상적으로 OK clicked가 출력이 된다. bind의 인자 추가 기능123456789var sum = function(a, b) &#123; return a + b;&#125;; var add1 = sum(10, 5);document.write(add1); // 15 var add2 = sum.bind(null, 5);document.write(add2(10)); // 15 5~6행은 일반적인 함수 호출방법이다. sum이라는 함수에 인자를 전달하여 return된 값을 add1에 저장하고, 출력한다. 그러나 8행을 보면, 첫 번째 인자로 null이 주어졌고, 이후에 9행에서 add2의 인자값으로 10이 주어졌다. 이렇게 bind를 사용하면 나중에 인자값을 추가할 수 있으며 이 인자는 원래 함수의 매개변수로 전달한다. 나중에 바인딩 된 함수에 전달하는 모든 추가 매개변수는 바인딩된 매개변수 다음에 전달된다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] call과 apply","slug":"JS-함수의-호출-방법-call과-apply","date":"2018-05-24T09:52:11.000Z","updated":"2018-05-24T11:21:53.139Z","comments":true,"path":"2018/05/24/JS-함수의-호출-방법-call과-apply/","link":"","permalink":"https://jess2.github.io/2018/05/24/JS-함수의-호출-방법-call과-apply/","excerpt":"","text":"함수의 호출 방법 - call과 applycall과 apply에 대해 알아보기 전에 먼저 함수의 기본적인 호출 방법에 대해 알아보자. 12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125; document.write(sum(2, 3)); // 출력결과 &gt; 5 sum이라는 함수에 매개변수로 두 개의 값을 받고 있으므로 이 함수를 호출할 때, sum(2, 3)이런 식으로 호출했다. 함수의 리턴값은 5다. 이 외에도 JavaScript에서는 기본적인 함수 호출 방법 이외의 다른 방법들을 제공한다. 함수의 호출 방법인 call과 apply에 대해 알아보자. call과 apply아래의 call Example과 apply Example은 위의 기본적인 함수 호출과 동일한 결과를 가져온다. call Example12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125;document.write(sum.call(null, 2, 3)); apply Example12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125; document.write(sum.apply(null, [2, 3])); 기본적으로 Function 객체는 call과 apply메소드를 가지고 있는데, sum도 Function객체의 인스턴스이기 때문에, 객체 Function의 메소드인 call과 apply를 호출할 수 있다. call과 apply는 비슷하지만, 매개변수를 전달하는 방식이 다르다. 개발자가 편한 방식을 선택하면 되는데, arguments객체를 그대로 전달해도 되거나 매개변수로 전달할 데이터가 이미 배열 형태로 준비되어 있다면 apply가 나을 것이고, 그렇지 않다면 call이 나을 것이다. 전달할 매개변수가 없다면 두 메소드는 완전히 동일하다. 그런데 왜 굳이 call과 apply같은 방식을 사용하여 함수를 호출해야 하는가? call과 apply를 사용하여 함수를 호출하면 그 함수를 해당 객체의 메소드로 만들어 버린다. 아래의 예제를 보자. Example12345678910111213o1 = &#123;val1:1, val2:2, val3:3&#125;;o2 = &#123;v1:10, v2:50, v3:100, v4:25&#125;; function sum()&#123; var _sum = 0; for(name in this)&#123; _sum += this[name]; &#125; return _sum;&#125; alert(sum.apply(o1)); // 결과 : 6alert(sum.apply(o2)); // 결과 : 185 우선 12행의 sum.apply(o1)를 살펴보자. sum.apply(o1)는 함수 sum을 객체 o1의 메소드로 만들고, sum을 호출한다. 이렇게 되면, 함수 sum안에 있는 this는 객체 o1을 뜻하게 되는 것이다. 함수 sum안에서 반복문을 돌면서 객체 o1의 키값들 (val1, val2, val3)이 차례대로 name이라는 값으로 들어가게 되며, this[name]의 값은 해당 키값의 value들을 말한다. 그래서 차례대로 1, 2, 3이 더해져 6이라는 결과가 나온 것이다.13행도 12행과 마찬가지로 실행된다. 아래의 또 다른 예제를 보자. Example1234567891011121314window.color = \"red\";var obj = &#123; color : \"blue\"&#125;; function func() &#123; document.write(this.color);&#125;; func(); // 출력결과 &gt; redfunc.call(this); // 출력결과 &gt; redfunc.call(obj); // 출력결과 &gt; bluefunc.apply(this); // 출력결과 &gt; redfunc.apply(obj); // 출력결과 &gt; blue (줄 10) : 일반적인 함수 호출 방법으로 함수를 호출했다. 함수 내의 this는 window객체를 가리키기 때문에 red가 출력된다. (줄 11) : call을 사용하여 함수를 호출했고 인자로 this를 넘겼다. 여기서 this는 window객체를 가리키기 때문에 함수 func()는 window의 메소드가 되는 것이다. 따라서 func()내의 this는 window를 가리키기 때문에 red가 출력된다. (줄 12) : call을 사용하여 함수를 호출했고 인자로 obj객체를 넘겼다. 따라서 함수 func()는 obj객체의 메소드가 되기 때문에 func()내의 this는 obj를 가리키므로 blue가 출력된다. (줄 13, 14) : 각각 줄 11, 12와 같은 원리로 red와 blue가 출력된다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 프로토타입(Prototype)","slug":"JS-프로토타입-Prototype","date":"2018-05-23T13:35:55.000Z","updated":"2018-05-24T11:21:53.152Z","comments":true,"path":"2018/05/23/JS-프로토타입-Prototype/","link":"","permalink":"https://jess2.github.io/2018/05/23/JS-프로토타입-Prototype/","excerpt":"","text":"프로토타입(Prototype)객체는 속성을 가질 수 있는데, prototype이라는 속성은 그 용도가 약속되어 있는 특수한 속성이다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된다. 자바스크립트의 모든 객체는 자신을 생성한 객체 원형에 대한 숨겨진 연결을 갖는다. 이 때, 자기 자신을 생성하기 위해 사용된 객체 원형을 프로토타입이라 한다. 자바스크립트의 모든 객체는 Object 객체의 프로토타입을 기반으로 확장되었기 때문에 이 연결의 끝은 Object 객체의 프로토타입 Object이다. 어떠한 객체가 만들어지기 위해 그 객체의 모태가 되는 것을 프로토타입이라고 한다. Example1234567891011function Ultra()&#123;&#125;Ultra.prototype.ultraProp = true; function Super()&#123;&#125;Super.prototype = new Ultra(); function Sub()&#123;&#125;Sub.prototype = new Super(); var o = new Sub();console.log(o.ultraProp); // 출력결과 &gt; true 생성자 Sub를 통해서 만들어진 객체 o가 Ultra의 속성인 ultraProp에 접근이 가능한 이유는 prototype 체인으로 Sub와 Ultra가 연결되어있기 때문이다. 내부적으로는 아래와 같은 일이 일어난다. 객체 o에서 ultraProp을 찾는다. 없다면 Sub.prototype.ultraProp을 찾는다. 없다면 Super.prototype.ultraProp을 찾는다. 없다면 Ultra.prototype.ultraProp을 찾는다. Example12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;Person.prototype.name = null;Person.prototype.introduce = function() &#123; return 'My name is ' + this.name;&#125; function Programmer(name) &#123; this.name = name;&#125;Programmer.prototype = new Person(); //상속Programmer.prototype.coding = function() &#123; return \"hello world\";&#125; var p1 = new Programmer('jessie');document.write(p1.introduce() + \"&lt;br/&gt;\"); //출력결과 : My name is jessiedocument.write(p1.coding() + \"&lt;br/&gt;\"); //출력결과 : hello world Programmer는 Person을 상속받았기 때문에 introduce라는 속성을 갖고 있지 않아도, Person의 속성인 introduce에 접근이 가능하기 때문에 18행의 p1.introduce()가 정상적으로 호출되어 출력이 된다. 프로토타입으로 메소드 생성 -&gt; 공간 절약우리는 아래와 같은 방법으로 생성자 함수와 인스턴스 객체를 만들 수 있다. 12345678910function Character(name, job) &#123; this.name = name; this.job = job; this.move = function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`); &#125;&#125; var char1 = new Character('루이스', '기사');char1.move(); 위의 코드에서 Character는 생성자 함수이며, char1은 인스턴스 객체다. Character생성자 함수 내에 존재하는 name과 job은 속성이고, move()는 메소드이다. 이 때 속성은 생성되는 인스턴스마다 다른 값을 적용해야 하므로 개별 영역이 필요하다. 하지만 메소드는 모든 인스턴스가 함께 쓰는 ‘공용체’이기 때문에 인스턴스의 속성으로 상속받기 보다는 별도 공간인 프로토타입에 정의하는 것이 좋다. 프로토타입 속성으로 정의하면 모든 인스턴스에서 하나의 프로토타입 속성만을 참조하기 때문에 인스턴스별로 중복되는 공간을 낭비하지 않을 수 있다. 따라서 속성은 ‘생성자 함수’에, 메소드는 ‘프로토타입 속성’으로 정의하는 것이 좋다. 위의 코드를 아래와 같이 수정하자. 12345678910111213141516//생성자 함수function Character(name, job) &#123; this.name = name; this.job = job;&#125; //프로토타입으로 메소드 생성Character.prototype.move = function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`);&#125; //객체 인스턴스var char1 = new Character('루이스', '기사'); //메소드 실행char1.move(); 그런데 추가해야 할 메소드가 많을 경우, 함수식으로 작성하면 너무 장황해진다. 메소드가 많을 경우에는 아래와 같이 작성하자. 123456789101112131415161718192021222324252627282930//생성자 함수function Character(name, job) &#123; this.name = name; this.job = job;&#125; //프로토타입으로 메소드 생성Character.prototype = &#123; move: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`); &#125;, attack: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 공격&lt;br/&gt;`); &#125;, escape: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 도망&lt;br/&gt;`); &#125;, dead: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 사망&lt;br/&gt;`); &#125;&#125; //객체 인스턴스var char1 = new Character('루이스', '기사'); //메소드 실행char1.move();char1.attack();char1.escape();char1.dead();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 클로저(Closure)","slug":"JS-자바스크립트-클로저-Closure","date":"2018-05-22T13:02:39.000Z","updated":"2018-05-24T11:21:53.129Z","comments":true,"path":"2018/05/22/JS-자바스크립트-클로저-Closure/","link":"","permalink":"https://jess2.github.io/2018/05/22/JS-자바스크립트-클로저-Closure/","excerpt":"","text":"클로저(Closure)클로저는 유효범위(Scope)를 기억하는 함수이다. 따라서 내부함수가 외부함수의 지역변수를 기억하여 접근할 수 있다. 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수는 외부함수의 지역변수에 접근할 수 있다. 다시 말해서, 클로저란, 내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미한다. 유효범위(scope)클로저에 대해 더 자세히 알아보기 전에 유효범위에 대해 알아보자. 변수는 크게 지역변수와 전역변수가 있다. 지역변수는 함수 내에서만 생명을 가지고, 함수가 종료되면 함수 내의 변수는 사라진다. 이렇게 함수 단위의 지역으로 변수의 유효 범위가 정해지는 것을 유효 범위(scope)라고 한다. 유효범위 Example1234567891011var global = 20; // 전역변수 function func() &#123; var local = 10; // 지역변수 document.write(global + '&lt;br&gt;'); // 출력결과 &gt; 20 document.write(local + '&lt;br&gt;'); // 출력결과 &gt; 10&#125; func();document.write(global + '&lt;br&gt;'); // 출력결과 &gt; 20document.write(local + '&lt;br&gt;'); // 출력결과 &gt; error 함수 밖의 전역 변수 global은 코드 전체에서 값이 유효하지만 함수 내의 지역 변수인 local은 함수 밖에서 사용할 수 없다. 함수가 종료되면 지역 변수의 유효범위가 종료되기 때문이다. 그러나 함수가 종료되어도 변수를 유지시킬 수 있는데, 그 방법이 바로 클로저이다. 클로저 Example123456789101112131415function outFunc() &#123; var value = 0; //내부 함수(클로저) function inFunc() &#123; return value += 1; &#125; return inFunc;&#125; var test = outFunc();document.write(test() + '&lt;br&gt;'); // 1document.write(test() + '&lt;br&gt;'); // 2document.write(test() + '&lt;br&gt;'); // 3 (줄 12) : 클로저 함수를 리턴받아 새로운 변수에 대입하면 outFunc()가 종료된 후에도 해당 함수의 지역변수 값을 계속 참조하고 변수 값이 생존하게 된다. 클로저 Example2123456789function outer() &#123; var title = 'hello world'; return function() &#123; alert(title); &#125;&#125; inner = outer();inner(); 8행에서 outer함수가 호출되었고, 그 결과가 inner변수에 담겼다. 그리고 9행으로 넘어오면 outer함수는 종료되었기 때문에 이 outer함수의 지역변수인 title은 소멸되는 것이 자연스럽다. 하지만 9행에서 inner함수를 호출했을 때, hello world가 잘 출력된다. 이것은 외부함수의 지역변수인 title이 소멸되지 않았다는 것이다. 이처럼 내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는다. for문과 클로저for문으로 클로저를 생성할 경우 실수가 빈번하게 발생한다. 다음 코드를 보자. 1234567891011var arr = []; for(var i=0; i&lt;3; i++) &#123; arr[i] = function() &#123; return i; &#125;&#125; document.write(arr[0]() + '&lt;br&gt;'); // 3document.write(arr[1]() + '&lt;br&gt;'); // 3document.write(arr[2]() + '&lt;br&gt;'); // 3 위 코드는 3만 세 번 출력한다. 클로저를 사용하려면 아래의 코드처럼 수정하자. 12345678910111213var arr = []; for(var i=0; i&lt;3; i++) &#123; (function(index)&#123; arr[index] = function() &#123; return index; &#125; &#125;)(i); // 익명 함수&#125; document.write(arr[0]() + '&lt;br&gt;'); // 0document.write(arr[1]() + '&lt;br&gt;'); // 1document.write(arr[2]() + '&lt;br&gt;'); // 2 위 코드는 정상적으로 0, 1, 2를 출력한다. for문 안의 처리문을 즉시 실행 익명 함수로 분리시키고 클로저가 for문의 i가 아닌 익명함수의 index변수를 참조하도록 한다. 참고로 ECMAScript 2015 (ES6)의 새로운 변수 선언문인 let 키워드로 변수를 선언하면 변수의 스코프가 블록 단위(기존 JS는 함수 단위이다.)로 엄격해지므로 이러한 문제가 발생하지 않는다. 아래의 코드를 보자. 1234567891011let arr = []; for(let i=0; i&lt;3; i++) &#123; arr[i] = function() &#123; return i; &#125;&#125; document.write(arr[0]() + '&lt;br&gt;'); // 0document.write(arr[1]() + '&lt;br&gt;'); // 1document.write(arr[2]() + '&lt;br&gt;'); // 2","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 크로스 도메인(Cross Domain)","slug":"JS-크로스-도메인-Cross-Domain","date":"2018-05-22T12:56:56.000Z","updated":"2018-05-22T13:21:45.578Z","comments":true,"path":"2018/05/22/JS-크로스-도메인-Cross-Domain/","link":"","permalink":"https://jess2.github.io/2018/05/22/JS-크로스-도메인-Cross-Domain/","excerpt":"","text":"자바스크립트 크로스 도메인(Cross Domain) 이슈우선, 크로스 도메인이란 무엇인지 알아보자. 크로스 도메인은 쉽게 말해서 서로 다른 도메인 간의 호출이다. 만약, 내가 개발한 웹사이트에서만 사용하기 위해 API 서버를 구축하였는데, 다른 웹 서비스에서 이 API 서버에 마음대로 접근하여 API를 호출하여 사용한다면 큰 문제가 된다. 그래서 JavaScript는 Same Origin Policy(동일 출처 정책)라는 정책을 두어, 다른 도메인의 서버에 요청하는 것을 차단시킨다. 즉, JavaScript는 동일한 도메인 내에서만 서버 요청을 허용한다는 것이다. 따라서 JavaScript를 이용하여 AJAX를 통해 다른 도메인의 서버의 URL을 호출하여 데이터를 가져올 수는 없다. 예를 들어 www.naver.com 도메인에서 호출된 AJAX는 www.naver.com 도메인 내에 있는 URL만을 호출할 수 있고, www.naver.com 도메인에서 www.google.com 의 URL을 AJAX로 호출할 수 없다. 하지만, 크로스 도메인을 허용해야 하는 경우가 있다.예를 들어 하나의 웹 사이트에서는 효율성이나 성능 등의 이유로 각 기능별로 여러 서버를 두는 경우가 많다. (API 서버, WAS 서버, 파일 서버 등) 그런데 이 서버들은 물리적으로 분리된 서버이고, 다른 용도로 구축된 서버이기 때문에 당연히 각각 다른 도메인을 가진 서버들이다. 그래서 크로스 도메인 이슈가 발생하기 때문에 서로 간의 AJAX 통신을 할 수가 없다. 그래서 크로스 도메인을 허용해야만 한다. 그렇다면, 크로스 도메인은 어떻게 허용해야 할까? CORS를 활성화 시키면 된다. CORS란, Cross-Origin Resource Sharing의 약자로, 웹 페이지의 제한된 자원을 외부 도메인에서의 요청(접근)을 허용해주는 것이다. CORS를 이용하여 특정 도메인에서 접근하는 것이 가능하도록 해준다. 즉, 크로스 도메인을 허용해준다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] null과 undefined 비교","slug":"JS-null과-undefined-비교","date":"2018-05-22T12:41:34.000Z","updated":"2018-05-22T12:49:04.561Z","comments":true,"path":"2018/05/22/JS-null과-undefined-비교/","link":"","permalink":"https://jess2.github.io/2018/05/22/JS-null과-undefined-비교/","excerpt":"","text":"null과 undefined 비교null과 undefined는 비슷해보이지만 엄연히 다르다. 이 두 개의 개념 차이를 명확히 알아두자. undefined먼저 undefined에 대해 알아보자. undefined는 변수를 선언만 하고 값을 할당하지 않은 것. 즉, 자료형이 결정되지 않은 상태이다. 123var a;document.write(a); // 출력결과 &gt; undefineddocument.write(typeof a); // 출력결과 &gt; undefined 위의 예시를 보면, a라는 변수를 선언만하고 값을 할당하지 않았기 때문에, 변수 a를 출력하면 undefined가 출력되고, 변수 a의 자료형이 결정되지 않은 상태이기 때문에, 변수 a의 type을 출력해도 undefined가 출력된다. null반면에 null은 변수를 선언하고, null이라는 빈 값을 할당한 것이다. 123var b = null; // null이라는 빈 값을 할당했다.document.write(b); // 출력결과 &gt; nulldocument.write(typeof b); // 출력결과 &gt; object 위의 예시를 보면 b라는 변수를 선언한 후, null이라는 값을 할당했다. null값은 객체로 취급되기 때문에, 변수 b를 출력하면 null이 출력되고, 변수 b의 type을 출력하면 object가 출력된다. null == undefined의 결과는 true아니, 지금까지 null과 undefined는 다른 것이라고 설명해 놓고 null == undefined의 결과는 왜 true인가? 12document.write(null == undefined); // 출력결과 &gt; truedocument.write(null === undefined); // 출력결과 &gt; false 비교 연산자 ==는 자료형이 다르면 자동 형변환으로 자료형을 강제로 맞춰서 비교한다. 따라서 undefined와 null은 자료형이 다르니 자바스크립트 엔진에서 자동으로 자료형을 강제로 맞춘 후, 둘 다 값이 없는 것이라는 사실을 확인하기 때문에 true를 반환한다. 반면에, 비교 연산자 ===는 자료형까지 동일한지 비교하기 때문에 null === undefined는 false를 반환한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[ES6] var, let, const 비교","slug":"ES6-var-let-const-비교","date":"2018-05-21T14:50:55.000Z","updated":"2018-05-24T11:21:53.125Z","comments":true,"path":"2018/05/21/ES6-var-let-const-비교/","link":"","permalink":"https://jess2.github.io/2018/05/21/ES6-var-let-const-비교/","excerpt":"","text":"var, let, const 비교기존 자바스크립트의 변수 선언 키워드 var과 ES6에서 새롭게 도입된 변수 선언 키워드 let과 const에 대해서 알아보자. var 키워드를 붙이지 않으면 어떻게 될까?먼저 var에 대해서 알아보자. var는 키워드 없이 변수를 선언하면 전역 변수가 된다. 전역 유효범위에 속해지기 때문에 코드 내에서 어디서든 변수에 접근할 수 있게 되는 것이다. 1234567891011function checkscope()&#123; var name = \"local\"; //var 키워드를 사용하여 변수를 선언&#125; function checkscope2()&#123; name2 = \"global\"; //var 키워드를 사용하지 않고 변수를 선언&#125; checkscope();checkscope2();document.write(name + \" \" + name2); //출력결과 &gt; global 위의 예제에서 var 키워드를 사용하여 선언한 변수인 name은 checkscope라는 함수 안에서의 지역변수이다. 하지만 var 키워드를 사용하지 않고 선언한 변수인 name2는 전역변수이다. 따라서 함수 밖에서 checkscope()와 checkscope2()함수를 호출한 후, name과 name2를 출력하면 name2의 값인 global만 출력되는 것을 확인할 수 있다. 변수 name은 함수의 지역변수이기 때문에 함수 밖에서는 사용할 수가 없지만 name2는 var 키워드를 붙이지 않아서 전역 변수가 되었기 때문에 함수 밖에서도 사용할 수 있다. Function-Scoped / Block-Scopedvar는 function-scoped이고, let과 const는 block-scoped이다. var는 function-scoped먼저 아래의 예시를 살펴보자. Example11234for(var i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 Example212345var i;for(i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 var i가 hoisting 되기 때문에 위의 Example1과 Example2는 동일한 코드라고 보면 된다. 따라서 i는 for문 밖에서도 사용할 수 있는 전역변수인 것이기 때문에 after loop i is 10라는 문장이 정상적으로 출력이 된다. (참고로, 호이스팅에 대한 내용은 여기에서 볼 수 있다.) 하지만 아래의 예시에서는 에러가 발생한다. Example3과 Example4는 동일한 코드라고 보면 되는데, Example3에서 선언된 변수가 포함된 scope 내에서 가장 위로 호이스팅 된 것이 Example4이다. 그런데 이 var i는 counter라는 함수 내에 존재하기 때문에, 함수 밖에서는 이 i라는 변수를 사용할 수가 없다. Example31234567function counter() &#123; for(var i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example412345678function counter() &#123; var i; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example1~4를 다시 살펴보자. 왜 Example1에서는 전역에서 i에 접근할 수 있고 Example2에서는 전역에서 i에 접근할 수 없는가? var 키워드가 function-scoped이기 때문이다! 변수 선언문이 호이스팅될 때 해당 scope의 가장 위로 호이스팅되는데, Example1에서는 변수 선언문이 함수 안에 포함되어 있지 않아서 전역으로 호이스팅되는 것이고, Example3에서는 변수 선언문이 함수 안에 포함되어 있기 때문에 함수 안에서 가장 위로 호이스팅 된다. var 키워드를 사용하지 않으면? 앞에서 var 키워드를 사용하지 않으면 전역 변수가 된다고 했다. 따라서 아래와 같이 전역에서 i에 접근할 수 있기 때문에 after loop i is 10라는 문장이 정상적으로 출력된다. 아래의 Example5와 Example6는 동일한 코드라고 보면 된다. Example51234567function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 Example612345678var i;function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 var / let / const var는 재선언과 재할당 모두 가능 let은 재선언 불가능, 재할당 가능 const는 재선언과 재할당 모두 불가능 var는 재선언 가능1234var a = 'hello';var a = 'world'; console.log(a); // 실행결과 &gt; world var는 재할당 가능1234var b = 'hello';b = 'world'; console.log(b); // 실행결과 &gt; world let은 재선언 불가능1234let c = 'hello';let c = 'world'; console.log(c); // 실행결과 &gt; Uncaught SyntaxError: Identifier 'c' has already been declared let은 재할당 가능1234let d = 'hello';d = 'world'; console.log(d); // 실행결과 &gt; world const는 재선언 불가능1234const e = 'hello';const e = 'world'; console.log(e); //Uncaught SyntaxError: Identifier 'e' has already been declared const는 재할당 불가능1234const f = 'hello';f = 'world'; console.log(f); //Uncaught SyntaxError: Assignment to constant variable.(상수 변수에 대입)","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/categories/ECMAScript6/"}],"tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/tags/ECMAScript6/"}]},{"title":"[Node.js] 노드의 기본 모듈 - url / fs / http","slug":"Node-js-노드의-기본-기능","date":"2018-05-18T16:01:42.000Z","updated":"2018-05-24T11:21:53.135Z","comments":true,"path":"2018/05/19/Node-js-노드의-기본-기능/","link":"","permalink":"https://jess2.github.io/2018/05/19/Node-js-노드의-기본-기능/","excerpt":"","text":"노드의 기본 모듈 - url / fs / http1. URL 모듈노드에서는 url 모듈을 사용하여 사이트 주소 정보를 url 객체로 만들 수 있다. url 모듈을 사용하면 일반 주소 문자열을 url 객체로 만들거나 url 객체에서 일반 문자열로 변환하는 일을 쉽게 할 수 있다. url 모듈을 이용해 주소 문자열을 객체로 만들면 문자열 안에 있던 각각의 정보를 나누어 그 객체의 속성으로 보관한다. (ex. protocol / host / query) 따라서 요청 프로토콜이 http인지 https인지를 구별하거나 요청 파라미터를 확인하고 싶다면 url 객체가 갖고 있는 속성 값을 확인하면 된다. 아래의 코드를 보자. Example12345678910var url = require('url');//주소 문자열을 URL 객체로 만들기var curURL = url.parse('https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=node');//URL 객체를 주소 문자열로 만들기var curStr = url.format(curURL);console.log('주소 문자열 : ' + curStr);console.log(curURL); (줄 1) : url 모듈을 사용하기 위해 require() 메소드를 호출했다. url 모듈을 로딩한 후 url이라는 변수 할당했다. (줄 4) : parse()메소드를 사용해 주소 문자열을 파싱하여 url 객체를 만들었다. (줄 7) : format()메소드를 사용해 URL 객체를 주소 문자열로 변환했다. 실행결과 파일을 실행하면 위와 같이 주소 문자열 정보와 URL 객체에 들어있는 속성들이 출력된다. 2. File System 모듈fs 모듈을 사용하면 파일 시스템에 접근할 수 있다. 메소드 이름 설명 readFile(filename, [encoding], [callback] 비동기식 IO로 파일을 읽어 들인다. readFileSync(filename, [encoding]) 동기식 IO로 파일을 읽어 들인다. writeFile(filename, data, encoding=’utf8’, [callback]) 비동기식 IO로 파일을 쓴다. writeFileSync(filename, data, encoding=’utf8’) 동기식 IO로 파일을 쓴다. 동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 동기식 IO로 읽어들인다.var data = fs.readFileSync('./package.json', 'utf8');console.log(data);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFileSync() 메소드를 사용하여 파일을 동기식 IO로 읽어드렸다. 동기식 IO로 파일 읽기 실행결과 파일을 동기식 IO로 읽어드렸기 때문에 파일을 전부 읽어서 출력한 후 ‘읽기 끝’을 출력하였다. 비동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 비동기식 IO로 읽어들인다.fs.readFile('./package.json', 'utf8', function(err, data) &#123; console.log(data);&#125;);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFile() 메소드를 사용하여 파일을 비동기식 IO로 읽어드렸다. 비동기식 IO로 파일 읽기 실행결과 파일을 비동기식 IO로 읽어드렸기 때문에 파일을 전부 읽기 전에 ‘읽기 끝’을 출력하였다. 이번엔 fs 모듈을 사용하여 파일을 직접 작성해보자. 비동기식 IO로 파일 쓰기12345678910var fs = require('fs');//파일에 데이터를 쓴다.fs.writeFile('./output.txt', 'Hello world!', function(err) &#123; if(err) &#123; console.log('Error: ' + err); &#125; console.log('output.txt 파일에 데이터 쓰기 완료');&#125;); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 writeFile() 메소드를 사용하여 비동기식 IO로 파일에 데이터를 썼다. 파일을 직접 열고 닫으면서 읽거나 쓰기실제로 파일을 읽거나 쓸 때는 한꺼번에 모든 데이터를 읽거나 쓰지 않고 조금씩 읽거나 쓰는 방식을 사용하는 경우도 많다. 또한 다른 곳에서 받아 온 데이터를 파일에 쓰는 경우도 있기 때문에 파일을 다루는 다양한 방식이 따로 정의되어 있다. 메소드 이름 설명 open(path, flags, [mode], [callback]]) 파일을 연다. read(fd, buffer, offset, length, position, [callback]) 지정한 부분의 파일 내용을 읽어 들인다. write(fd, buffer, offset, length, position, [callback]) 파일의 지정한 부분에 데이터를 쓴다. close(fd, [callback]) 파일을 닫는다. 12345678910111213141516var fs = require('fs');fs.open('./output.txt', 'w', function(err, fd) &#123; if(err) throw err; var buf = new Buffer('안녕\\n'); fs.write(fd, buf, 0, buf.length, null, function(err, written, buffer) &#123; if(err) throw err; console.log(err, written, buffer); fs.close(fd, function() &#123; console.log('파일 열고 데이터 쓰고 파일 닫기 완료'); &#125;); &#125;);&#125;); 파일을 열기 위해 open()메소드를 호출할 때 세 개의 파라미터가 전달되었다. 첫 번째 파라미터는 파일의 이름, 두 번째 파라미터는 파일을 읽거나 쓰기 위한 플래그이다. 대표적인 플래그의 종류에 대해 알아보자. flags 설명 r 읽기에 사용하는 플래그이다. 파일이 없으면 예외가 발생한다. w 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. w+ 읽기와 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. a+ 읽기와 추가에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용에 새로운 내용을 추가한다. 3. HTTP 모듈http 모듈은 노드의 가장 기본적인 모듈이며, http 서버와 클라이언트를 생성하는 것과 관련된 모든 기능을 담당한다. 웹 서버의 생성과 실행1234567891011121314//서버를 생성var http = require('http');var server = http.createServer();//서버를 실행server.listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;);//10초 후 서버 종료setTimeout(function() &#123; console.log('서버 종료'); server.close();&#125;,10000); http 모듈을 사용하기 위해 require()메소드를 호출했고 createServer()메소드를 이용해서 서버를 생성했다. listen()메소드를 이용해서 서버를 실행했고 close()메소드를 이용해서 서버를 종료했다. response 객체위의 예제에서 서버를 실행한 후 http://127.0.0.1:52273 에 접속해도 웹 브라우저에는 아무것도 출력되지 않을 것이다. 요청만 하고 응답을 하지 않았기 때문이다. 클라이언트에 웹 페이지를 제공하려면 응답 메시지를 작성해야 한다. 응답 메시지를 작성할 때는 response 객체를 생성한다. 123456require('http').createServer(function(request, response) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end('&lt;h1&gt;hello web server with node.js&lt;/h1&gt;');&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;); 코드를 실행한 후 http://127.0.0.1:52273 에 접속하면 웹 브라우저에 아래와 같이 출력된다. 그러나 자바스크립트 파일 위에서 모든 html 페이지를 문자열로 작성하는 것은 매우 비효율적이다. 그 대신 File System 모듈을 사용하여 서버에 존재하는 html 페이지를 클라이언트에 제공할 수 있다. File System 모듈을 사용한 html 페이지 제공1234567891011121314//모듈을 추출한다var fs = require('fs');var http = require('http');//웹 서버를 생성하고 실행한다http.createServer(function(request, response) &#123; //html 파일을 읽는다 fs.readFile('htmlPage.html', function(error, data) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end(data); &#125;);&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;) fs 모듈과 http 모듈을 사용하기 위해 require() 메소드를 호출했고 createServer()메소드로 웹 서버를 생성했다. 그 후, readFile()메소드로 htmlPage.html파일을 읽어와서 응답 메시지를 작성했다. htmlPage.html파일은 아래와 같이 작성했다. 12&lt;h1&gt;This is htmlPage&lt;/h1&gt;&lt;p&gt;Hello world! I'm Jessie&lt;/p&gt; 실행결과","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드의 특징","slug":"Node-js-노드의-특징","date":"2018-05-18T13:36:09.000Z","updated":"2018-05-22T13:09:02.881Z","comments":true,"path":"2018/05/18/Node-js-노드의-특징/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-js-노드의-특징/","excerpt":"","text":"노드의 특징노드(Node.js)는 JavaScript를 이용해서 서버를 만들 수 있는 개발 도구다. 하나의 언어로 Front-end와 Back-end를 모두 다룰 수 있다니, 이 얼마나 매력적인가! 그럼 이 매력적인 노드의 특징에 대해서 본격적으로 살펴보자. 1. 빠른 개발 가능노드의 첫 번째 특징으로는 빠른 개발이 가능하다는 것이다. Javascript 기반이고 개발 구조가 단순화 되어 있어서 빠르게 개발이 가능하다. 또한 클라이언트에서 자바스크립트로 front-end를 개발하던 FE 개발자들도 손쉽게 서버 프로그래밍이 가능하다. 한 마디로, 하나의 언어로 애플리케이션 전체를 구현할 수 있기 때문에 개발을 빠르게 할 수 있는 것이다. 또한 socket.io를 이용한 웹 push 구현이 매우 쉽게 가능하다. 웹 브라우저의 종류에 따라서 push 메커니즘을 자동으로 선택하여 사용하고 있으며 이러한 push 메커니즘은 socket.io API 내에 추상화 되어 있기 때문에 어떤 기술로 구현이 되어 있든 개발자 입장에서는 socket.io만 쓰면 간단하게 웹 기반의 push 서비스가 구현이 가능하다. 2. 모듈과 패키지소스 파일 하나에 실행하려는 기능이 모두 들어 있다면 코드가 굉장히 복잡해질 것이다. 그래서 메인이 되는 자바스크립트 파일을 두고, 일부 기능만 담당하는 코드를 별도의 파일로 만들 수 있는데 이것을 모듈(Module)이라고 한다. 모듈 안에 있는 코드를 사용하고 싶다면 require() 함수로 모듈을 호출하면 된다. 이렇게 불러들인 모듈은 자바스크립트 객체로 인식되며, 그 객체를 참조하여 모듈에 넣어둔 기능을 사용할 수 있다. 또한, 여러 개의 모듈을 합쳐서 하나의 패키지(Package)로 만들어 두면 다른 개발자들도 npm 프로그램으로 손쉽게 이 패키지를 설치하여 사용할 수 있다. 3. 비동기 입출력(Non-Blocking IO)하나의 요청 처리가 끝날 때까지 기다렸다가 그 다음 요청 처리를 해야 한다면 굉장히 비효율적일 것이다. 노드는 하나의 요청 처리가 끝날 때까지 기다리지 않고 다른 요청을 동시에 처리할 수 있는 비동기 입출력(Non-Blocking IO) 방식을 적용했다. 그럼 프로그램에서 작업을 진행하는 중간에 다른 작업을 어떻게 진행할 수 있는 것일까? 프로그램에서 다른 작업을 처리할 수 있는 시점이 되면 콜백 함수(Callback Function)을 호출한다. 따라서 파일 읽기 작업을 할 때, 프로그램이 파일 읽기 작업이 끝날 때까지 대기하지 않아도 파일을 다 읽은 시점에 통보를 받고 파일의 내용을 화면에 보여준다. 이렇게 콜백 함수를 이용하기 때문에 비동기 입출력 방식은 대기 시간이 필요 없고 속도가 빠르다. 4. 이벤트 기반 입출력자바스크립트는 코드를 한 줄씩 해석하면서 실행하는 인터프리터(Interpreter) 방식을 사용하기 때문에 속도가 느려서 문제였는데, 이 문제는 크롬의 V8 자바스크립트 엔진이 나오면서 해결되었다. V8 엔진은 자바스크립트 코드를 네이티브 코드로 바꾼 후 실행할 수 있는데, 노드는 이 V8 엔진을 이용해 자바스크립트 코드를 빠르게 실행할 수 있다. 노드를 설치한 다음 노드로 프로그램을 만들어 실행하면 크롬 V8 엔진 위에서 실행된다. 그런데 이 V8 엔진에서 동작하는 노드의 아키텍처에서 가장 중요한 부분 중 하나가 이벤트를 받아 처리하는 기능이다. 노드에는 이벤트를 보내고 받을 수 있도록 EventEmitter라는 것이 만들어져 있다. 노드의 객체는 EventEmitter를 상속받을 수 있으며 상속받은 후에는 EventEmitter 객체의 on()과 emit() 등의 메소드를 사용할 수 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드로 만들 수 있는 서버","slug":"Node-노드로-만들-수-있는-서버","date":"2018-05-18T12:04:34.000Z","updated":"2018-05-22T13:09:02.881Z","comments":true,"path":"2018/05/18/Node-노드로-만들-수-있는-서버/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-노드로-만들-수-있는-서버/","excerpt":"","text":"노드로 만들 수 있는 서버노드의 등장으로 인해 웹 브라우저에서 동작하는 JavaScript를 이용하여 서버까지 구현이 가능해졌다. 하나의 언어로 애플리케이션 전체를 구현할 수 있게 된 것이다. 서버가 뭔데? 다른 곳에 있는 단말에 데이터를 달라고 요청하는 프로그램을 클라이언트(Client), 다른 곳에서 요청받은 명령을 처리해주는 프로그램을 서버(Server)라고 한다. 이때 서버는 포트(Port)를 지정하여 그 포트로 요청을 받을 수 있다. 서버를 만들어 실행하면 지정된 포트에서 클라이언트로부터 요청을 받아 처리한다. 또한 대부분의 서버는 데이터베이스에 연결할 수 있도록 구성되기 때문에 클라이언트에서 보내온 데이터를 저장하거나 저장된 데이터를 조회한 후 클라이언트에 보내준다. 굉장히 다양한 서버의 유형 중에서 우리가 많이 사용하는 웹 브라우저에서 접속하는 서버를 웹 서버라고 하며, HTTP 프로토콜을 사용한다. 그럼 웹 서버 말고 또 어떤 서버가 있을까? 만들려는 애플리케이션이 무엇인지에 따라 필요한 서버 유형이 달라진다. 웹 서버, 채팅 서버, 모바일 서버 등 서버의 유형은 굉장히 다양하지만 우리는 웹 브라우저에서 웹 문서를 요청할 때 필요한 기능을 수행하는 웹 서버에 대해서 알아보자. 노드로 웹 서버를 만들자Node.js에서 제공하는 다양한 모듈(Module)을 사용하여 웹 서버를 만들 수 있다. 익스프레스(Express) 몽고디비(MongoDB) 뷰 탬플릿(View Template) 패스포트(Passport) 웹 프레임워크인 익스프레스(Express)가 웹 서버에 필요한 파일들을 자동으로 만들어주기 때문에 익스프레스로 기본 구조를 만들고, 몽고디비(MongoDB)를 이용해서 데이터를 저장하거나 조회할 수 있다. 뷰 탬플릿(View Template)은 클라이언트에 응답을 보낼 때 사용하려고 미리 웹 문서의 원형(Template)을 만들어 놓은 것이며, 패스포트(Passport)는 사용자 로그인이나 회원가입을 위해 사용한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[JS] 이벤트 버블링과 이벤트 캡쳐링","slug":"JS-이벤트-버블링과-캡쳐링","date":"2018-05-16T10:06:13.000Z","updated":"2018-05-22T13:09:02.884Z","comments":true,"path":"2018/05/16/JS-이벤트-버블링과-캡쳐링/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-이벤트-버블링과-캡쳐링/","excerpt":"","text":"Event Bubbling / Event Capturing버블링과 캡쳐링을 본격적으로 알아보기 전에 간단한 코드를 한 번 살펴보자. 1234&lt;div onclick=\"alert('The DIV handler!')\"&gt; DIV 태그 &lt;p&gt;P 태그&lt;/p&gt;&lt;/div&gt; See the Pen Ryewge by SoyeonJung (@je_ss2) on CodePen. div태그에 alert(&#39;The DIV handler!&#39;)라는 이벤트 핸들러를 할당하였고, p태그에는 어떠한 핸들러도 할당하지 않았다. 그런데 p태그를 클릭해도 div태그에 할당된 핸들러가 실행이 된다. 조금 이상하다.p태그를 클릭했는데 왜 div태그에 할당된 핸들러가 실행이 되는 것일까? 버블링 때문이다.자바스크립트의 이벤트 버블링 때문에 위의 코드에서 div태그 안에 있는 p태그를 클릭하면 div태그에 할당된 클릭 이벤트가 발생하는 것이다. 그럼, 버블링이 정확히 뭔데? 이벤트 버블링의 원리는 간단하다. “엘리먼트에 이벤트가 발생하면 먼저 해당 엘리먼트의 핸들러를 실행시킨 후, 그의 부모 엘리먼트의 핸들러를 실행시키고, 또 그 위의 조상 엘리먼트들의 핸들러를 실행시킨다” 마치 버블이 아래에서 위로 올라가는 것과 같아서 버블링이라고 한다. 아래의 예시를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJaNgQ by SoyeonJung (@je_ss2) on CodePen. form태그에는 alert(&#39;form&#39;)클릭 이벤트를 줬고, div태그에는 alert(&#39;div&#39;)클릭 이벤트를 줬고, p태그에는 alert(&#39;p&#39;)클릭 이벤트를 줬다. 그런데, p태그는 div태그가 감싸고 있고, 또 그 div태그는 form태그가 감싸고 있다. 따라서 이벤트 버블링으로 인해, p태그를 클릭하면 p -&gt; div -&gt; form순서로 알림창이 뜬다. 그리고 div태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. p태그를 클릭하면 window에서부터 p태그까지 요소 중간에 있는 이벤트들을 전부 검색해서 따로 메모리에 가지고 있다고 생각하면 된다. 해당 엘리먼트부터 차례대로 위로 올라가면서 이벤트들을 발생시키는 것, 그것이 바로 이벤트 버블링이다. 버블링 멈추기기본적으로 이벤트 버블링은 항상 발생한다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJabwo by SoyeonJung (@je_ss2) on CodePen. form태그와 div태그에만 이벤트 핸들러를 주고, p태그에는 이벤트 핸들러를 주지 않았다. 하지만, 이벤트 버블링으로 인해 p 태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. 이벤트 버블링이 발생되지 않았으면 좋겠어 이벤트 버블링은 event.stopPropagation()을 이용해서 간단하게 멈출 수 있다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"event.stopPropagation()\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen xjyGGK by SoyeonJung (@je_ss2) on CodePen. p태그에 onclick=&quot;event.stopPropagation()&quot;를 주었더니, p태그를 클릭해도 아까처럼 이벤트가 발생하지 않는다. 이벤트 버블링이 작동하지 않기 때문이다. 이벤트 캡쳐링그렇다면 이번에는 이벤트 캡쳐링에 대해서 알아보자. 이벤트 캡쳐링도 이벤트 버블링과 비슷하다. 버블링이 아래에서 위로 올라가는 것이라면, 캡쳐링은 위에서 아래로 내려가는 것이다. addEventListener를 이용하여 버블링과 캡쳐링에 대해서 살펴보자. capturing단계에서 이벤트를 catch하려면 addEventListener의 세 번째 요소를 true로 설정해줘야 한다. 기본적으로 addEventListener의 세 번째 요소를 작성하지 않으면 default값이 false인데, false로 설정할 경우, 핸들러는 버블링 단계로 설정된다. 반면에 true로 설정할 경우, 핸들러는 캡쳐링 단계로 설정된다. 먼저 addEventListener의 세 번째 요소를 작성하지 않았을 경우를 살펴보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName));&#125; See the Pen mLzywJ by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 P -&gt; DIV -&gt; FORM -&gt; BODY -&gt; HTML순서로 알림창이 열린다. addEventListener의 세 번째 요소를 작성하지 않아서 기본값인 false로 되었기 때문에 핸들러가 버블링 단계로 설정되었기 때문이다. 이번에는 addEventListener의 세 번째 요소를 true로 작성해보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName), true);&#125; See the Pen WJabBd by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 HTML -&gt; BODY -&gt; FORM -&gt; DIV -&gt; P순서로 알림창이 열린다. addEventListener의 세 번째 요소를 true로 작성했기 때문에 핸들러가 캡쳐링 단계로 설정되었기 때문이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 호이스팅(Hoisting)","slug":"JS-호이스팅-Hoisting","date":"2018-05-15T15:43:24.000Z","updated":"2018-05-24T11:21:53.129Z","comments":true,"path":"2018/05/16/JS-호이스팅-Hoisting/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-호이스팅-Hoisting/","excerpt":"","text":"자바스크립트의 호이스팅(Hoisting)Hoisting이란, 선언을 현재 스크립트 또는 현재 함수의 맨 위로 이동시키는 JavaScript의 기본 동작이다. 만약, 변수가 함수 내에서 정의되었을 경우 선언이 함수 내부의 최상위로 호이스팅되고, 함수 밖에 정의되었을 경우에는 선언이 전역 컨텍스트의 최상위로 호이스팅 된다. 호이스팅 때문에 변수를 선언하기 전에 사용할 수 있다. JavaScript에서는 변수를 선언하기 전에 사용할 수 있다. 아래에 선언을 해도 선언한 것이 Hoisting 되어 위로 끌어올려지기 때문이다. 아래의 Code-1과 Code-2는 동일한 코드라고 보면 된다. Code-1123456x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 var x; // x 선언 Code-212345var x; // x 선언x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 할당은 호이스팅하지 않고, 선언만 호이스팅한다.JavaScript는 Hoisting을 할 때, 선언만 Hoisting하고, 할당은 Hoisting을 하지 않는다. 다음 Code-3과 Code-4는 동일한 코드라고 보면 된다. Code-3123456var x = 5; // x를 선언하고 x에 5를 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined var y = 7; // y를 선언하고 y에 7을 할당 Code-41234567var x = 5; // x를 선언하고 x에 5를 할당var y; // y를 선언 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined y = 7; // y에 7을 할당 위의 Code-3과 Code-4에서 y에 할당된 값인 7이 출력되지 않고 undefined가 출력되는 이유는, 선언만 위쪽으로 끌어 올려지고(Hoisting), 할당은 위로 끌어 올려지지 않기 때문이다. hosting으로 인해 y는 사용되기 전에 선언은 되었지만, 할당이 수행되지 않았기 때문에 y값은 undefined가 되는 것이다. Hosting은 많은 개발자에게 알려지지 않거나 간과 된 JavaScript의 동작인데, 개발자가 Hosting을 이해하지 못하면 프로그램에 버그가 있을 수 있다. 따라서, 버그를 피하려면 항상 모든 범위의 시작 부분에 모든 변수를 선언하고 할당해야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] onclick과 addEventListener 비교","slug":"JS-onclick과-addEventListener-비교","date":"2018-05-15T14:27:19.000Z","updated":"2018-05-22T13:09:02.840Z","comments":true,"path":"2018/05/15/JS-onclick과-addEventListener-비교/","link":"","permalink":"https://jess2.github.io/2018/05/15/JS-onclick과-addEventListener-비교/","excerpt":"","text":"onclick과 addEventListener 비교자바스크립트에서 클릭 이벤트를 줄 때 어떤 방식을 사용하는가?onclick을 사용할 수도, addEventListener를 사용할 수도 있지만, 어떤 것을 사용하든 이 두 가지가 서로 어떻게 다른 지 알고 있어야 한다. onclick은 하나만, addEventListener는 여러 개를. onclick에는 하나의 콜백만 지정할 수 있지만, addEventListener를 사용하면 여러 개의 이벤트 리스너를 추가할 수 있다. 따라서 만약 onclick 이벤트 핸들러를 두 번 이상 사용한다면, 기존 이벤트 핸들러를 덮어쓰기 때문에 가장 아래에 추가한 핸들러만 제대로 작동한다. 반면, addEventListener는 기존 이벤트 핸들러를 덮어 쓰지 않고 얼마든지 계속해서 핸들러를 추가해도 모든 핸들러가 정상적으로 작동한다. 아래의 코드를 보자. ExampleSee the Pen onclick과 addEventListener 비교 by SoyeonJung (@je_ss2) on CodePen. btn에 onclick과 addEventListener 이벤트 핸들러를 각각 두 개씩, 총 네 개의 핸들러를 만들었지만, alert(&#39;onclick-1&#39;)는 실행되지 않고 나머지 세 개만 실행되는 것을 확인할 수 있다. 그럼 onclick은 왜 있는거야?이쯤 되면 이런 의문이 들 수 있다. 클릭 이벤트를 주고 싶으면 그냥 addEventListener를 사용하면 되지, onclick은 굳이 왜 만든 것일까? onclick은 초기 DOM Level-0에서 제공하던 기능이고, 그 이후 버전인 Level-2에서 추가된 것이 addEventListener이다. addEventListener는 이벤트 캡쳐링, 버블링 같은 이벤트 방식을 설정할 수 있기 때문에 이벤트 제어에 있어서 더욱 유용하지만, addEventListener는 IE8 이하에서는 작동을 하지 않는다. 그래서 구형 브라우저 지원이 필요하면 onclick을 사용하거나 다른 방법을 찾아야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]}]}