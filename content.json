{"meta":{"title":"Jess2's Blog","subtitle":"제씨의 기술블로그","description":null,"author":"Soyeon Jung","url":"https://jess2.github.io"},"pages":[],"posts":[{"title":"[Node.js] 노드의 기본 기능","slug":"Node-js-노드의-기본-기능","date":"2018-05-18T16:01:42.000Z","updated":"2018-05-19T05:15:03.761Z","comments":true,"path":"2018/05/19/Node-js-노드의-기본-기능/","link":"","permalink":"https://jess2.github.io/2018/05/19/Node-js-노드의-기본-기능/","excerpt":"","text":"노드의 기본 기능URL 모듈노드에서는 url 모듈을 사용하여 사이트 주소 정보를 url 객체로 만들 수 있다. url 모듈을 사용하면 일반 주소 문자열을 url 객체로 만들거나 url 객체에서 일반 문자열로 변환하는 일을 쉽게 할 수 있다. url 모듈을 이용해 주소 문자열을 객체로 만들면 문자열 안에 있던 각각의 정보를 나누어 그 객체의 속성으로 보관한다. (ex. protocol / host / query) 따라서 요청 프로토콜이 http인지 https인지를 구별하거나 요청 파라미터를 확인하고 싶다면 url 객체가 갖고 있는 속성 값을 확인하면 된다. 아래의 코드를 보자. Example12345678910var url = require('url');//주소 문자열을 URL 객체로 만들기var curURL = url.parse('https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=node');//URL 객체를 주소 문자열로 만들기var curStr = url.format(curURL);console.log('주소 문자열 : ' + curStr);console.log(curURL); (줄 1) : url 모듈을 사용하기 위해 require() 메소드를 호출했다. url 모듈을 로딩한 후 url이라는 변수 할당했다. (줄 4) : parse()메소드를 사용해 주소 문자열을 파싱하여 url 객체를 만들었다. (줄 7) : format()메소드를 사용해 URL 객체를 주소 문자열로 변환했다. 실행결과 파일을 실행하면 위와 같이 주소 문자열 정보와 URL 객체에 들어있는 속성들이 출력된다. fs 모듈fs 모듈을 사용하면 파일 시스템에 접근할 수 있다. 동기식 IO와 비동기식 IO 기능을 이용할 수 있는데, readFileSync()메소드를 사용하면 파일을 동기식 IO로 읽어들이고, readFile()메소드를 사용하면 파일을 비동기식 IO로 읽어들인다. 동기식 IO12345678var fs = require('fs');//파일을 동기식 IO로 읽어들인다.var data = fs.readFileSync('./package.json', 'utf8');console.log(data);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFileSync() 메소드를 사용하여 파일을 동기식 IO로 읽어드렸다. 동기식 IO 실행결과 파일을 동기식 IO로 읽어드렸기 때문에 파일을 전부 읽어서 출력한 후 ‘읽기 끝’을 출력하였다. 비동기식 IO12345678var fs = require('fs');//파일을 비동기식 IO로 읽어들인다.fs.readFile('./package.json', 'utf8', function(err, data) &#123; console.log(data);&#125;);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFile() 메소드를 사용하여 파일을 비동기식 IO로 읽어드렸다. 비동기식 IO 실행결과 파일을 비동기식 IO로 읽어드렸기 때문에 파일을 전부 읽기 전에 ‘읽기 끝’을 출력하였다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드의 특징","slug":"Node-js-노드의-특징","date":"2018-05-18T13:36:09.000Z","updated":"2018-05-18T14:24:04.490Z","comments":true,"path":"2018/05/18/Node-js-노드의-특징/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-js-노드의-특징/","excerpt":"","text":"노드의 특징노드(Node.js)는 JavaScript를 이용해서 서버를 만들 수 있는 개발 도구다. 하나의 언어로 Front-end와 Back-end를 모두 다룰 수 있다니, 이 얼마나 매력적인가! 그럼 이 매력적인 노드의 특징에 대해서 본격적으로 살펴보자. 1. 빠른 개발 가능노드의 첫 번째 특징으로는 빠른 개발이 가능하다는 것이다. Javascript 기반이고 개발 구조가 단순화 되어 있어서 빠르게 개발이 가능하다. 또한 클라이언트에서 자바스크립트로 front-end를 개발하던 FE 개발자들도 손쉽게 서버 프로그래밍이 가능하다. 한 마디로, 하나의 언어로 애플리케이션 전체를 구현할 수 있기 때문에 개발을 빠르게 할 수 있는 것이다. 또한 socket.io를 이용한 웹 push 구현이 매우 쉽게 가능하다. 웹 브라우저의 종류에 따라서 push 메커니즘을 자동으로 선택하여 사용하고 있으며 이러한 push 메커니즘은 socket.io API 내에 추상화 되어 있기 때문에 어떤 기술로 구현이 되어 있든 개발자 입장에서는 socket.io만 쓰면 간단하게 웹 기반의 push 서비스가 구현이 가능하다. 2. 모듈과 패키지소스 파일 하나에 실행하려는 기능이 모두 들어 있다면 코드가 굉장히 복잡해질 것이다. 그래서 메인이 되는 자바스크립트 파일을 두고, 일부 기능만 담당하는 코드를 별도의 파일로 만들 수 있는데 이것을 모듈(Module)이라고 한다. 모듈 안에 있는 코드를 사용하고 싶다면 require() 함수로 모듈을 호출하면 된다. 이렇게 불러들인 모듈은 자바스크립트 객체로 인식되며, 그 객체를 참조하여 모듈에 넣어둔 기능을 사용할 수 있다. 또한, 여러 개의 모듈을 합쳐서 하나의 패키지(Package)로 만들어 두면 다른 개발자들도 npm 프로그램으로 손쉽게 이 패키지를 설치하여 사용할 수 있다. 3. 비동기 입출력(Non-Blocking IO)하나의 요청 처리가 끝날 때까지 기다렸다가 그 다음 요청 처리를 해야 한다면 굉장히 비효율적일 것이다. 노드는 하나의 요청 처리가 끝날 때까지 기다리지 않고 다른 요청을 동시에 처리할 수 있는 비동기 입출력(Non-Blocking IO) 방식을 적용했다. 그럼 프로그램에서 작업을 진행하는 중간에 다른 작업을 어떻게 진행할 수 있는 것일까? 프로그램에서 다른 작업을 처리할 수 있는 시점이 되면 콜백 함수(Callback Function)을 호출한다. 따라서 파일 읽기 작업을 할 때, 프로그램이 파일 읽기 작업이 끝날 때까지 대기하지 않아도 파일을 다 읽은 시점에 통보를 받고 파일의 내용을 화면에 보여준다. 이렇게 콜백 함수를 이용하기 때문에 비동기 입출력 방식은 대기 시간이 필요 없고 속도가 빠르다. 4. 이벤트 기반 입출력자바스크립트는 코드를 한 줄씩 해석하면서 실행하는 인터프리터(Interpreter) 방식을 사용하기 때문에 속도가 느려서 문제였는데, 이 문제는 크롬의 V8 자바스크립트 엔진이 나오면서 해결되었다. V8 엔진은 자바스크립트 코드를 네이티브 코드로 바꾼 후 실행할 수 있는데, 노드는 이 V8 엔진을 이용해 자바스크립트 코드를 빠르게 실행할 수 있다. 노드를 설치한 다음 노드로 프로그램을 만들어 실행하면 크롬 V8 엔진 위에서 실행된다. 그런데 이 V8 엔진에서 동작하는 노드의 아키텍처에서 가장 중요한 부분 중 하나가 이벤트를 받아 처리하는 기능이다. 노드에는 이벤트를 보내고 받을 수 있도록 EventEmitter라는 것이 만들어져 있다. 노드의 객체는 EventEmitter를 상속받을 수 있으며 상속받은 후에는 EventEmitter 객체의 on()과 emit() 등의 메소드를 사용할 수 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드로 만들 수 있는 서버","slug":"Node-노드로-만들-수-있는-서버","date":"2018-05-18T12:04:34.000Z","updated":"2018-05-18T13:31:37.006Z","comments":true,"path":"2018/05/18/Node-노드로-만들-수-있는-서버/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-노드로-만들-수-있는-서버/","excerpt":"","text":"노드로 만들 수 있는 서버노드의 등장으로 인해 웹 브라우저에서 동작하는 JavaScript를 이용하여 서버까지 구현이 가능해졌다. 하나의 언어로 애플리케이션 전체를 구현할 수 있게 된 것이다. 서버가 뭔데? 다른 곳에 있는 단말에 데이터를 달라고 요청하는 프로그램을 클라이언트(Client), 다른 곳에서 요청받은 명령을 처리해주는 프로그램을 서버(Server)라고 한다. 이때 서버는 포트(Port)를 지정하여 그 포트로 요청을 받을 수 있다. 서버를 만들어 실행하면 지정된 포트에서 클라이언트로부터 요청을 받아 처리한다. 또한 대부분의 서버는 데이터베이스에 연결할 수 있도록 구성되기 때문에 클라이언트에서 보내온 데이터를 저장하거나 저장된 데이터를 조회한 후 클라이언트에 보내준다. 굉장히 다양한 서버의 유형 중에서 우리가 많이 사용하는 웹 브라우저에서 접속하는 서버를 웹 서버라고 하며, HTTP 프로토콜을 사용한다. 그럼 웹 서버 말고 또 어떤 서버가 있을까? 만들려는 애플리케이션이 무엇인지에 따라 필요한 서버 유형이 달라진다. 웹 서버, 채팅 서버, 모바일 서버 등 서버의 유형은 굉장히 다양하지만 우리는 웹 브라우저에서 웹 문서를 요청할 때 필요한 기능을 수행하는 웹 서버에 대해서 알아보자. 노드로 웹 서버를 만들자Node.js에서 제공하는 다양한 모듈(Module)을 사용하여 웹 서버를 만들 수 있다. 익스프레스(Express) 몽고디비(MongoDB) 뷰 탬플릿(View Template) 패스포트(Passport) 웹 프레임워크인 익스프레스(Express)가 웹 서버에 필요한 파일들을 자동으로 만들어주기 때문에 익스프레스로 기본 구조를 만들고, 몽고디비(MongoDB)를 이용해서 데이터를 저장하거나 조회할 수 있다. 뷰 탬플릿(View Template)은 클라이언트에 응답을 보낼 때 사용하려고 미리 웹 문서의 원형(Template)을 만들어 놓은 것이며, 패스포트(Passport)는 사용자 로그인이나 회원가입을 위해 사용한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[JS] 이벤트 버블링과 이벤트 캡쳐링","slug":"JS-이벤트-버블링과-캡쳐링","date":"2018-05-16T10:06:13.000Z","updated":"2018-05-16T11:19:54.118Z","comments":true,"path":"2018/05/16/JS-이벤트-버블링과-캡쳐링/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-이벤트-버블링과-캡쳐링/","excerpt":"","text":"Event Bubbling / Event Capturing버블링과 캡쳐링을 본격적으로 알아보기 전에 간단한 코드를 한 번 살펴보자. 1234&lt;div onclick=\"alert('The DIV handler!')\"&gt; DIV 태그 &lt;p&gt;P 태그&lt;/p&gt;&lt;/div&gt; See the Pen Ryewge by SoyeonJung (@je_ss2) on CodePen. div태그에 alert(&#39;The DIV handler!&#39;)라는 이벤트 핸들러를 할당하였고, p태그에는 어떠한 핸들러도 할당하지 않았다. 그런데 p태그를 클릭해도 div태그에 할당된 핸들러가 실행이 된다. 조금 이상하다.p태그를 클릭했는데 왜 div태그에 할당된 핸들러가 실행이 되는 것일까? 버블링 때문이다.자바스크립트의 이벤트 버블링 때문에 위의 코드에서 div태그 안에 있는 p태그를 클릭하면 div태그에 할당된 클릭 이벤트가 발생하는 것이다. 그럼, 버블링이 정확히 뭔데? 이벤트 버블링의 원리는 간단하다. “엘리먼트에 이벤트가 발생하면 먼저 해당 엘리먼트의 핸들러를 실행시킨 후, 그의 부모 엘리먼트의 핸들러를 실행시키고, 또 그 위의 조상 엘리먼트들의 핸들러를 실행시킨다” 마치 버블이 아래에서 위로 올라가는 것과 같아서 버블링이라고 한다. 아래의 예시를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJaNgQ by SoyeonJung (@je_ss2) on CodePen. form태그에는 alert(&#39;form&#39;)클릭 이벤트를 줬고, div태그에는 alert(&#39;div&#39;)클릭 이벤트를 줬고, p태그에는 alert(&#39;p&#39;)클릭 이벤트를 줬다. 그런데, p태그는 div태그가 감싸고 있고, 또 그 div태그는 form태그가 감싸고 있다. 따라서 이벤트 버블링으로 인해, p태그를 클릭하면 p -&gt; div -&gt; form순서로 알림창이 뜬다. 그리고 div태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. p태그를 클릭하면 window에서부터 p태그까지 요소 중간에 있는 이벤트들을 전부 검색해서 따로 메모리에 가지고 있다고 생각하면 된다. 해당 엘리먼트부터 차례대로 위로 올라가면서 이벤트들을 발생시키는 것, 그것이 바로 이벤트 버블링이다. 버블링 멈추기기본적으로 이벤트 버블링은 항상 발생한다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJabwo by SoyeonJung (@je_ss2) on CodePen. form태그와 div태그에만 이벤트 핸들러를 주고, p태그에는 이벤트 핸들러를 주지 않았다. 하지만, 이벤트 버블링으로 인해 p 태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. 이벤트 버블링이 발생되지 않았으면 좋겠어 이벤트 버블링은 event.stopPropagation()을 이용해서 간단하게 멈출 수 있다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"event.stopPropagation()\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen xjyGGK by SoyeonJung (@je_ss2) on CodePen. p태그에 onclick=&quot;event.stopPropagation()&quot;를 주었더니, p태그를 클릭해도 아까처럼 이벤트가 발생하지 않는다. 이벤트 버블링이 작동하지 않기 때문이다. 이벤트 캡쳐링그렇다면 이번에는 이벤트 캡쳐링에 대해서 알아보자. 이벤트 캡쳐링도 이벤트 버블링과 비슷하다. 버블링이 아래에서 위로 올라가는 것이라면, 캡쳐링은 위에서 아래로 내려가는 것이다. addEventListener를 이용하여 버블링과 캡쳐링에 대해서 살펴보자. capturing단계에서 이벤트를 catch하려면 addEventListener의 세 번째 요소를 true로 설정해줘야 한다. 기본적으로 addEventListener의 세 번째 요소를 작성하지 않으면 default값이 false인데, false로 설정할 경우, 핸들러는 버블링 단계로 설정된다. 반면에 true로 설정할 경우, 핸들러는 캡쳐링 단계로 설정된다. 먼저 addEventListener의 세 번째 요소를 작성하지 않았을 경우를 살펴보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName));&#125; See the Pen mLzywJ by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 P -&gt; DIV -&gt; FORM -&gt; BODY -&gt; HTML순서로 알림창이 열린다. addEventListener의 세 번째 요소를 작성하지 않아서 기본값인 false로 되었기 때문에 핸들러가 버블링 단계로 설정되었기 때문이다. 이번에는 addEventListener의 세 번째 요소를 true로 작성해보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName), true);&#125; See the Pen WJabBd by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 HTML -&gt; BODY -&gt; FORM -&gt; DIV -&gt; P순서로 알림창이 열린다. addEventListener의 세 번째 요소를 true로 작성했기 때문에 핸들러가 캡쳐링 단계로 설정되었기 때문이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 호이스팅(Hoisting)","slug":"JS-호이스팅-Hoisting","date":"2018-05-15T15:43:24.000Z","updated":"2018-05-15T16:19:14.440Z","comments":true,"path":"2018/05/16/JS-호이스팅-Hoisting/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-호이스팅-Hoisting/","excerpt":"","text":"자바스크립트의 호이스팅(Hoisting)Hoisting이란, 선언을 현재 스크립트 또는 현재 함수의 맨 위로 이동시키는 JavaScript의 기본 동작이다. 만약, 변수가 함수 내에서 정의되었을 경우 선언이 함수 내부의 최상위로 호이스팅되고, 함수 밖에 정의되었을 경우에는 선언이 전역 컨텍스트의 최상위로 호이스팅 된다. 호이스팅 때문에 변수를 선언하기 전에 사용할 수 있다. JavaScript에서는 변수를 선언하기 전에 사용할 수 있다. 아래에 선언을 해도 선언한 것이 Hoisting 되어 위로 끌어올려지기 때문이다. 아래의 Code-1과 Code-2는 동일한 코드라고 보면 된다. Code-1123456x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 var x; // x 선언 Code-212345var x; // x 선언x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 할당은 호이스팅하지 않고, 선언만 호이스팅한다.JavaScript는 Hoisting을 할 때, 선언만 Hoisting하고, 할당은 Hoisting을 하지 않는다. 다음 Code-3과 Code-4는 동일한 코드라고 보면 된다. Code-3123456var x = 5; // x를 선언하고 x에 5를 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined var y = 7; // y를 선언하고 y에 7을 할당 Code-41234567var x = 5; // x를 선언하고 x에 5를 할당var y; // y를 선언 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined y = 7; // y에 7을 할당 위의 Code-3과 Code-4에서 y에 할당된 값인 7이 출력되지 않고 undefined가 출력되는 이유는, 선언만 위쪽으로 끌어 올려지고(Hoisting), 할당은 위로 끌어 올려지지 않기 때문이다. hosting으로 인해 y는 사용되기 전에 선언은 되었지만, 할당이 수행되지 않았기 때문에 y값은 undefined가 되는 것이다. Hosting은 많은 개발자에게 알려지지 않거나 간과 된 JavaScript의 동작인데, 개발자가 Hosting을 이해하지 못하면 프로그램에 버그가 있을 수 있다. 따라서, 버그를 피하려면 항상 모든 범위의 시작 부분에 모든 변수를 선언하고 할당해야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] onclick과 addEventListener 비교","slug":"JS-onclick과-addEventListener-비교","date":"2018-05-15T14:27:19.000Z","updated":"2018-05-15T16:19:39.202Z","comments":true,"path":"2018/05/15/JS-onclick과-addEventListener-비교/","link":"","permalink":"https://jess2.github.io/2018/05/15/JS-onclick과-addEventListener-비교/","excerpt":"","text":"onclick과 addEventListener 비교자바스크립트에서 클릭 이벤트를 줄 때 어떤 방식을 사용하는가?onclick을 사용할 수도, addEventListener를 사용할 수도 있지만, 어떤 것을 사용하든 이 두 가지가 서로 어떻게 다른 지 알고 있어야 한다. onclick은 하나만, addEventListener는 여러 개를. onclick에는 하나의 콜백만 지정할 수 있지만, addEventListener를 사용하면 여러 개의 이벤트 리스너를 추가할 수 있다. 따라서 만약 onclick 이벤트 핸들러를 두 번 이상 사용한다면, 기존 이벤트 핸들러를 덮어쓰기 때문에 가장 아래에 추가한 핸들러만 제대로 작동한다. 반면, addEventListener는 기존 이벤트 핸들러를 덮어 쓰지 않고 얼마든지 계속해서 핸들러를 추가해도 모든 핸들러가 정상적으로 작동한다. 아래의 코드를 보자. ExampleSee the Pen onclick과 addEventListener 비교 by SoyeonJung (@je_ss2) on CodePen. btn에 onclick과 addEventListener 이벤트 핸들러를 각각 두 개씩, 총 네 개의 핸들러를 만들었지만, alert(&#39;onclick-1&#39;)는 실행되지 않고 나머지 세 개만 실행되는 것을 확인할 수 있다. 그럼 onclick은 왜 있는거야?이쯤 되면 이런 의문이 들 수 있다. 클릭 이벤트를 주고 싶으면 그냥 addEventListener를 사용하면 되지, onclick은 굳이 왜 만든 것일까? onclick은 초기 DOM Level-0에서 제공하던 기능이고, 그 이후 버전인 Level-2에서 추가된 것이 addEventListener이다. addEventListener는 이벤트 캡쳐링, 버블링 같은 이벤트 방식을 설정할 수 있기 때문에 이벤트 제어에 있어서 더욱 유용하지만, addEventListener는 IE8 이하에서는 작동을 하지 않는다. 그래서 구형 브라우저 지원이 필요하면 onclick을 사용하거나 다른 방법을 찾아야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]}]}