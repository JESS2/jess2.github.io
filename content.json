{"meta":{"title":"Jess2's Blog","subtitle":"제씨의 기술블로그","description":null,"author":"Soyeon Jung","url":"https://jess2.github.io"},"pages":[],"posts":[{"title":"[JS] 크로스 도메인(Cross Domain)","slug":"JS-크로스-도메인-Cross-Domain","date":"2018-05-22T12:56:56.000Z","updated":"2018-05-22T13:01:27.000Z","comments":true,"path":"2018/05/22/JS-크로스-도메인-Cross-Domain/","link":"","permalink":"https://jess2.github.io/2018/05/22/JS-크로스-도메인-Cross-Domain/","excerpt":"","text":"자바스크립트 크로스 도메인(Cross Domain) 이슈우선, 크로스 도메인이란 무엇인지 알아보자. 크로스 도메인은 쉽게 말해서 서로 다른 도메인 간의 호출이다. 만약, 내가 개발한 웹사이트에서만 사용하기 위해 API 서버를 구축하였는데, 다른 웹 서비스에서 이 API 서버에 마음대로 접근하여 API를 호출하여 사용한다면 큰 문제가 된다. 그래서 JavaScript는 Same Origin Policy(동일 출처 정책)라는 정책을 두어, 다른 도메인의 서버에 요청하는 것을 차단시킨다. 즉, JavaScript는 동일한 도메인 내에서만 서버 요청을 허용한다는 것이다. 따라서 JavaScript를 이용하여 AJAX를 통해 다른 도메인의 서버의 URL을 호출하여 데이터를 가져올 수는 없다. 예를 들어 www.naver.com 도메인에서 호출된 AJAX는 www.naver.com 도메인 내에 있는 URL만을 호출할 수 있고, www.naver.com 도메인에서 www.google.com 의 URL을 AJAX로 호출할 수 없다. 하지만, 크로스 도메인을 허용해야 하는 경우가 있다.예를 들어 하나의 웹 사이트에서는 효율성이나 성능 등의 이유로 각 기능별로 여러 서버를 두는 경우가 많다. (API 서버, WAS 서버, 파일 서버 등) 그런데 이 서버들은 물리적으로 분리된 서버이고, 다른 용도로 구축된 서버이기 때문에 당연히 각각 다른 도메인을 가진 서버들이다. 그래서 크로스 도메인 이슈가 발생하기 때문에 서로 간의 AJAX 통신을 할 수가 없다. 그래서 크로스 도메인을 허용해야만 한다. 그렇다면, 크로스 도메인은 어떻게 허용해야 할까? CORS를 활성화 시키면 된다. CORS란, Cross-Origin Resource Sharing의 약자로, 웹 페이지의 제한된 자원을 외부 도메인에서의 요청(접근)을 허용해주는 것이다. CORS를 이용하여 특정 도메인에서 접근하는 것이 가능하도록 해준다. 즉, 크로스 도메인을 허용해준다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] null과 undefined 비교","slug":"JS-null과-undefined-비교","date":"2018-05-22T12:41:34.000Z","updated":"2018-05-22T12:49:04.561Z","comments":true,"path":"2018/05/22/JS-null과-undefined-비교/","link":"","permalink":"https://jess2.github.io/2018/05/22/JS-null과-undefined-비교/","excerpt":"","text":"null과 undefined 비교null과 undefined는 비슷해보이지만 엄연히 다르다. 이 두 개의 개념 차이를 명확히 알아두자. undefined먼저 undefined에 대해 알아보자. undefined는 변수를 선언만 하고 값을 할당하지 않은 것. 즉, 자료형이 결정되지 않은 상태이다. 123var a;document.write(a); // 출력결과 &gt; undefineddocument.write(typeof a); // 출력결과 &gt; undefined 위의 예시를 보면, a라는 변수를 선언만하고 값을 할당하지 않았기 때문에, 변수 a를 출력하면 undefined가 출력되고, 변수 a의 자료형이 결정되지 않은 상태이기 때문에, 변수 a의 type을 출력해도 undefined가 출력된다. null반면에 null은 변수를 선언하고, null이라는 빈 값을 할당한 것이다. 123var b = null; // null이라는 빈 값을 할당했다.document.write(b); // 출력결과 &gt; nulldocument.write(typeof b); // 출력결과 &gt; object 위의 예시를 보면 b라는 변수를 선언한 후, null이라는 값을 할당했다. null값은 객체로 취급되기 때문에, 변수 b를 출력하면 null이 출력되고, 변수 b의 type을 출력하면 object가 출력된다. null == undefined의 결과는 true아니, 지금까지 null과 undefined는 다른 것이라고 설명해 놓고 null == undefined의 결과는 왜 true인가? 12document.write(null == undefined); // 출력결과 &gt; truedocument.write(null === undefined); // 출력결과 &gt; false 비교 연산자 ==는 자료형이 다르면 자동 형변환으로 자료형을 강제로 맞춰서 비교한다. 따라서 undefined와 null은 자료형이 다르니 자바스크립트 엔진에서 자동으로 자료형을 강제로 맞춘 후, 둘 다 값이 없는 것이라는 사실을 확인하기 때문에 true를 반환한다. 반면에, 비교 연산자 ===는 자료형까지 동일한지 비교하기 때문에 null === undefined는 false를 반환한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[ES6] var, let, const 비교","slug":"ES6-var-let-const-비교","date":"2018-05-21T14:50:55.000Z","updated":"2018-05-21T15:59:17.836Z","comments":true,"path":"2018/05/21/ES6-var-let-const-비교/","link":"","permalink":"https://jess2.github.io/2018/05/21/ES6-var-let-const-비교/","excerpt":"","text":"var, let, const 비교기존 자바스크립트의 변수 선언 키워드 var과 ES6에서 새롭게 도입된 변수 선언 키워드 let과 const에 대해서 알아보자. var 키워드를 붙이지 않으면 어떻게 될까?먼저 var에 대해서 알아보자. var는 키워드 없이 변수를 선언하면 전역 변수가 된다. 전역 유효범위에 속해지기 때문에 코드 내에서 어디서든 변수에 접근할 수 있게 되는 것이다. 1234567891011function checkscope()&#123; var name = \"local\"; //var 키워드를 사용하여 변수를 선언&#125; function checkscope2()&#123; name2 = \"global\"; //var 키워드를 사용하지 않고 변수를 선언&#125; checkscope();checkscope2();document.write(name + \" \" + name2); //출력결과 &gt; global 위의 예제에서 var 키워드를 사용하여 선언한 변수인 name은 checkscope라는 함수 안에서의 지역변수이다. 하지만 var 키워드를 사용하지 않고 선언한 변수인 name2는 전역변수이다. 따라서 함수 밖에서 checkscope()와 checkscope2()함수를 호출한 후, name과 name2를 출력하면 name2의 값인 global만 출력되는 것을 확인할 수 있다. 변수 name은 함수의 지역변수이기 때문에 함수 밖에서는 사용할 수가 없지만 name2는 var 키워드를 붙이지 않아서 전역 변수가 되었기 때문에 함수 밖에서도 사용할 수 있다. Function-Scoped / Block-Scopedvar는 function-scoped이고, let과 const는 block-scoped이다. var는 function-scoped먼저 아래의 예시를 살펴보자. Example11234for(var i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 Example212345var i;for(i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 var i가 hoisting 되기 때문에 위의 Example1과 Example2는 동일한 코드라고 보면 된다. 따라서 i는 for문 밖에서도 사용할 수 있는 전역변수인 것이기 때문에 after loop i is 10라는 문장이 정상적으로 출력이 된다. (참고로, 호이스팅에 대한 내용은 여기에서 볼 수 있다.) 하지만 아래의 예시에서는 에러가 발생한다. Example3과 Example4는 동일한 코드라고 보면 되는데, Example3에서 선언된 변수가 포함된 scope 내에서 가장 위로 호이스팅 된 것이 Example4이다. 그런데 이 var i는 counter라는 함수 내에 존재하기 때문에, 함수 밖에서는 이 i라는 변수를 사용할 수가 없다. Example31234567function counter() &#123; for(var i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example412345678function counter() &#123; var i; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example1~4를 다시 살펴보자. 왜 Example1에서는 전역에서 i에 접근할 수 있고 Example2에서는 전역에서 i에 접근할 수 없는가? var 키워드가 function-scoped이기 때문이다! 변수 선언문이 호이스팅될 때 해당 scope의 가장 위로 호이스팅되는데, Example1에서는 변수 선언문이 함수 안에 포함되어 있지 않아서 전역으로 호이스팅되는 것이고, Example3에서는 변수 선언문이 함수 안에 포함되어 있기 때문에 함수 안에서 가장 위로 호이스팅 된다. var 키워드를 사용하지 않으면? 앞에서 var 키워드를 사용하지 않으면 전역 변수가 된다고 했다. 따라서 아래와 같이 전역에서 i에 접근할 수 있기 때문에 after loop i is 10라는 문장이 정상적으로 출력된다. 아래의 Example5와 Example6는 동일한 코드라고 보면 된다. Example51234567function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 Example612345678var i;function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 var / let / const var는 재선언과 재할당 모두 가능 let은 재선언 불가능, 재할당 가능 const는 재선언과 재할당 모두 불가능 var는 재선언 가능1234var a = 'hello';var a = 'world'; console.log(a); // 실행결과 &gt; world var는 재할당 가능1234var b = 'hello';b = 'world'; console.log(b); // 실행결과 &gt; world let은 재선언 불가능1234let c = 'hello';let c = 'world'; console.log(c); // 실행결과 &gt; Uncaught SyntaxError: Identifier 'c' has already been declared let은 재할당 가능1234let d = 'hello';d = 'world'; console.log(d); // 실행결과 &gt; world const는 재선언 불가능1234const e = 'hello';const e = 'world'; console.log(e); //Uncaught SyntaxError: Identifier 'e' has already been declared const는 재할당 불가능1234const f = 'hello';f = 'world'; console.log(f); //Uncaught SyntaxError: Assignment to constant variable.(상수 변수에 대입)","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/categories/ECMAScript6/"}],"tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/tags/ECMAScript6/"}]},{"title":"[Node.js] 노드의 기본 모듈 - url / fs / http","slug":"Node-js-노드의-기본-기능","date":"2018-05-18T16:01:42.000Z","updated":"2018-05-21T14:44:19.427Z","comments":true,"path":"2018/05/19/Node-js-노드의-기본-기능/","link":"","permalink":"https://jess2.github.io/2018/05/19/Node-js-노드의-기본-기능/","excerpt":"","text":"노드의 기본 모듈 - url / fs / http1. URL 모듈노드에서는 url 모듈을 사용하여 사이트 주소 정보를 url 객체로 만들 수 있다. url 모듈을 사용하면 일반 주소 문자열을 url 객체로 만들거나 url 객체에서 일반 문자열로 변환하는 일을 쉽게 할 수 있다. url 모듈을 이용해 주소 문자열을 객체로 만들면 문자열 안에 있던 각각의 정보를 나누어 그 객체의 속성으로 보관한다. (ex. protocol / host / query) 따라서 요청 프로토콜이 http인지 https인지를 구별하거나 요청 파라미터를 확인하고 싶다면 url 객체가 갖고 있는 속성 값을 확인하면 된다. 아래의 코드를 보자. Example12345678910var url = require('url');//주소 문자열을 URL 객체로 만들기var curURL = url.parse('https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=node');//URL 객체를 주소 문자열로 만들기var curStr = url.format(curURL);console.log('주소 문자열 : ' + curStr);console.log(curURL); (줄 1) : url 모듈을 사용하기 위해 require() 메소드를 호출했다. url 모듈을 로딩한 후 url이라는 변수 할당했다. (줄 4) : parse()메소드를 사용해 주소 문자열을 파싱하여 url 객체를 만들었다. (줄 7) : format()메소드를 사용해 URL 객체를 주소 문자열로 변환했다. 실행결과 파일을 실행하면 위와 같이 주소 문자열 정보와 URL 객체에 들어있는 속성들이 출력된다. 2. File System 모듈fs 모듈을 사용하면 파일 시스템에 접근할 수 있다. 메소드 이름 설명 readFile(filename, [encoding], [callback] 비동기식 IO로 파일을 읽어 들인다. readFileSync(filename, [encoding]) 동기식 IO로 파일을 읽어 들인다. writeFile(filename, data, encoding=’utf8’, [callback]) 비동기식 IO로 파일을 쓴다. writeFileSync(filename, data, encoding=’utf8’) 동기식 IO로 파일을 쓴다. 동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 동기식 IO로 읽어들인다.var data = fs.readFileSync('./package.json', 'utf8');console.log(data);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFileSync() 메소드를 사용하여 파일을 동기식 IO로 읽어드렸다. 동기식 IO로 파일 읽기 실행결과 파일을 동기식 IO로 읽어드렸기 때문에 파일을 전부 읽어서 출력한 후 ‘읽기 끝’을 출력하였다. 비동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 비동기식 IO로 읽어들인다.fs.readFile('./package.json', 'utf8', function(err, data) &#123; console.log(data);&#125;);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFile() 메소드를 사용하여 파일을 비동기식 IO로 읽어드렸다. 비동기식 IO로 파일 읽기 실행결과 파일을 비동기식 IO로 읽어드렸기 때문에 파일을 전부 읽기 전에 ‘읽기 끝’을 출력하였다. 이번엔 fs 모듈을 사용하여 파일을 직접 작성해보자. 비동기식 IO로 파일 쓰기12345678910var fs = require('fs');//파일에 데이터를 쓴다.fs.writeFile('./output.txt', 'Hello world!', function(err) &#123; if(err) &#123; console.log('Error: ' + err); &#125; console.log('output.txt 파일에 데이터 쓰기 완료');&#125;); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 writeFile() 메소드를 사용하여 비동기식 IO로 파일에 데이터를 썼다. 파일을 직접 열고 닫으면서 읽거나 쓰기실제로 파일을 읽거나 쓸 때는 한꺼번에 모든 데이터를 읽거나 쓰지 않고 조금씩 읽거나 쓰는 방식을 사용하는 경우도 많다. 또한 다른 곳에서 받아 온 데이터를 파일에 쓰는 경우도 있기 때문에 파일을 다루는 다양한 방식이 따로 정의되어 있다. 메소드 이름 설명 open(path, flags, [mode], [callback]]) 파일을 연다. read(fd, buffer, offset, length, position, [callback]) 지정한 부분의 파일 내용을 읽어 들인다. write(fd, buffer, offset, length, position, [callback]) 파일의 지정한 부분에 데이터를 쓴다. close(fd, [callback]) 파일을 닫는다. 12345678910111213141516var fs = require('fs');fs.open('./output.txt', 'w', function(err, fd) &#123; if(err) throw err; var buf = new Buffer('안녕\\n'); fs.write(fd, buf, 0, buf.length, null, function(err, written, buffer) &#123; if(err) throw err; console.log(err, written, buffer); fs.close(fd, function() &#123; console.log('파일 열고 데이터 쓰고 파일 닫기 완료'); &#125;); &#125;);&#125;); 파일을 열기 위해 open()메소드를 호출할 때 세 개의 파라미터가 전달되었다. 첫 번째 파라미터는 파일의 이름, 두 번째 파라미터는 파일을 읽거나 쓰기 위한 플래그이다. 대표적인 플래그의 종류에 대해 알아보자. flags 설명 r 읽기에 사용하는 플래그이다. 파일이 없으면 예외가 발생한다. w 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. w+ 읽기와 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. a+ 읽기와 추가에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용에 새로운 내용을 추가한다. 3. HTTP 모듈http 모듈은 노드의 가장 기본적인 모듈이며, http 서버와 클라이언트를 생성하는 것과 관련된 모든 기능을 담당한다. 웹 서버의 생성과 실행1234567891011121314//서버를 생성var http = require('http');var server = http.createServer();//서버를 실행server.listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;);//10초 후 서버 종료setTimeout(function() &#123; console.log('서버 종료'); server.close();&#125;,10000); http 모듈을 사용하기 위해 require()메소드를 호출했고 createServer()메소드를 이용해서 서버를 생성했다. listen()메소드를 이용해서 서버를 실행했고 close()메소드를 이용해서 서버를 종료했다. response 객체위의 예제에서 서버를 실행한 후 http://127.0.0.1:52273 에 접속해도 웹 브라우저에는 아무것도 출력되지 않을 것이다. 요청만 하고 응답을 하지 않았기 때문이다. 클라이언트에 웹 페이지를 제공하려면 응답 메시지를 작성해야 한다. 응답 메시지를 작성할 때는 response 객체를 생성한다. 123456require('http').createServer(function(request, response) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end('&lt;h1&gt;hello web server with node.js&lt;/h1&gt;');&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;); 코드를 실행한 후 http://127.0.0.1:52273 에 접속하면 웹 브라우저에 아래와 같이 출력된다. 그러나 자바스크립트 파일 위에서 모든 html 페이지를 문자열로 작성하는 것은 매우 비효율적이다. 그 대신 File System 모듈을 사용하여 서버에 존재하는 html 페이지를 클라이언트에 제공할 수 있다. File System 모듈을 사용한 html 페이지 제공1234567891011121314//모듈을 추출한다var fs = require('fs');var http = require('http');//웹 서버를 생성하고 실행한다http.createServer(function(request, response) &#123; //html 파일을 읽는다 fs.readFile('htmlPage.html', function(error, data) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end(data); &#125;);&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;) fs 모듈과 http 모듈을 사용하기 위해 require() 메소드를 호출했고 createServer()메소드로 웹 서버를 생성했다. 그 후, readFile()메소드로 htmlPage.html파일을 읽어와서 응답 메시지를 작성했다. htmlPage.html파일은 아래와 같이 작성했다. 12&lt;h1&gt;This is htmlPage&lt;/h1&gt;&lt;p&gt;Hello world! I'm Jessie&lt;/p&gt; 실행결과","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드의 특징","slug":"Node-js-노드의-특징","date":"2018-05-18T13:36:09.000Z","updated":"2018-05-18T14:24:04.490Z","comments":true,"path":"2018/05/18/Node-js-노드의-특징/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-js-노드의-특징/","excerpt":"","text":"노드의 특징노드(Node.js)는 JavaScript를 이용해서 서버를 만들 수 있는 개발 도구다. 하나의 언어로 Front-end와 Back-end를 모두 다룰 수 있다니, 이 얼마나 매력적인가! 그럼 이 매력적인 노드의 특징에 대해서 본격적으로 살펴보자. 1. 빠른 개발 가능노드의 첫 번째 특징으로는 빠른 개발이 가능하다는 것이다. Javascript 기반이고 개발 구조가 단순화 되어 있어서 빠르게 개발이 가능하다. 또한 클라이언트에서 자바스크립트로 front-end를 개발하던 FE 개발자들도 손쉽게 서버 프로그래밍이 가능하다. 한 마디로, 하나의 언어로 애플리케이션 전체를 구현할 수 있기 때문에 개발을 빠르게 할 수 있는 것이다. 또한 socket.io를 이용한 웹 push 구현이 매우 쉽게 가능하다. 웹 브라우저의 종류에 따라서 push 메커니즘을 자동으로 선택하여 사용하고 있으며 이러한 push 메커니즘은 socket.io API 내에 추상화 되어 있기 때문에 어떤 기술로 구현이 되어 있든 개발자 입장에서는 socket.io만 쓰면 간단하게 웹 기반의 push 서비스가 구현이 가능하다. 2. 모듈과 패키지소스 파일 하나에 실행하려는 기능이 모두 들어 있다면 코드가 굉장히 복잡해질 것이다. 그래서 메인이 되는 자바스크립트 파일을 두고, 일부 기능만 담당하는 코드를 별도의 파일로 만들 수 있는데 이것을 모듈(Module)이라고 한다. 모듈 안에 있는 코드를 사용하고 싶다면 require() 함수로 모듈을 호출하면 된다. 이렇게 불러들인 모듈은 자바스크립트 객체로 인식되며, 그 객체를 참조하여 모듈에 넣어둔 기능을 사용할 수 있다. 또한, 여러 개의 모듈을 합쳐서 하나의 패키지(Package)로 만들어 두면 다른 개발자들도 npm 프로그램으로 손쉽게 이 패키지를 설치하여 사용할 수 있다. 3. 비동기 입출력(Non-Blocking IO)하나의 요청 처리가 끝날 때까지 기다렸다가 그 다음 요청 처리를 해야 한다면 굉장히 비효율적일 것이다. 노드는 하나의 요청 처리가 끝날 때까지 기다리지 않고 다른 요청을 동시에 처리할 수 있는 비동기 입출력(Non-Blocking IO) 방식을 적용했다. 그럼 프로그램에서 작업을 진행하는 중간에 다른 작업을 어떻게 진행할 수 있는 것일까? 프로그램에서 다른 작업을 처리할 수 있는 시점이 되면 콜백 함수(Callback Function)을 호출한다. 따라서 파일 읽기 작업을 할 때, 프로그램이 파일 읽기 작업이 끝날 때까지 대기하지 않아도 파일을 다 읽은 시점에 통보를 받고 파일의 내용을 화면에 보여준다. 이렇게 콜백 함수를 이용하기 때문에 비동기 입출력 방식은 대기 시간이 필요 없고 속도가 빠르다. 4. 이벤트 기반 입출력자바스크립트는 코드를 한 줄씩 해석하면서 실행하는 인터프리터(Interpreter) 방식을 사용하기 때문에 속도가 느려서 문제였는데, 이 문제는 크롬의 V8 자바스크립트 엔진이 나오면서 해결되었다. V8 엔진은 자바스크립트 코드를 네이티브 코드로 바꾼 후 실행할 수 있는데, 노드는 이 V8 엔진을 이용해 자바스크립트 코드를 빠르게 실행할 수 있다. 노드를 설치한 다음 노드로 프로그램을 만들어 실행하면 크롬 V8 엔진 위에서 실행된다. 그런데 이 V8 엔진에서 동작하는 노드의 아키텍처에서 가장 중요한 부분 중 하나가 이벤트를 받아 처리하는 기능이다. 노드에는 이벤트를 보내고 받을 수 있도록 EventEmitter라는 것이 만들어져 있다. 노드의 객체는 EventEmitter를 상속받을 수 있으며 상속받은 후에는 EventEmitter 객체의 on()과 emit() 등의 메소드를 사용할 수 있다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node.js] 노드로 만들 수 있는 서버","slug":"Node-노드로-만들-수-있는-서버","date":"2018-05-18T12:04:34.000Z","updated":"2018-05-18T13:31:37.006Z","comments":true,"path":"2018/05/18/Node-노드로-만들-수-있는-서버/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node-노드로-만들-수-있는-서버/","excerpt":"","text":"노드로 만들 수 있는 서버노드의 등장으로 인해 웹 브라우저에서 동작하는 JavaScript를 이용하여 서버까지 구현이 가능해졌다. 하나의 언어로 애플리케이션 전체를 구현할 수 있게 된 것이다. 서버가 뭔데? 다른 곳에 있는 단말에 데이터를 달라고 요청하는 프로그램을 클라이언트(Client), 다른 곳에서 요청받은 명령을 처리해주는 프로그램을 서버(Server)라고 한다. 이때 서버는 포트(Port)를 지정하여 그 포트로 요청을 받을 수 있다. 서버를 만들어 실행하면 지정된 포트에서 클라이언트로부터 요청을 받아 처리한다. 또한 대부분의 서버는 데이터베이스에 연결할 수 있도록 구성되기 때문에 클라이언트에서 보내온 데이터를 저장하거나 저장된 데이터를 조회한 후 클라이언트에 보내준다. 굉장히 다양한 서버의 유형 중에서 우리가 많이 사용하는 웹 브라우저에서 접속하는 서버를 웹 서버라고 하며, HTTP 프로토콜을 사용한다. 그럼 웹 서버 말고 또 어떤 서버가 있을까? 만들려는 애플리케이션이 무엇인지에 따라 필요한 서버 유형이 달라진다. 웹 서버, 채팅 서버, 모바일 서버 등 서버의 유형은 굉장히 다양하지만 우리는 웹 브라우저에서 웹 문서를 요청할 때 필요한 기능을 수행하는 웹 서버에 대해서 알아보자. 노드로 웹 서버를 만들자Node.js에서 제공하는 다양한 모듈(Module)을 사용하여 웹 서버를 만들 수 있다. 익스프레스(Express) 몽고디비(MongoDB) 뷰 탬플릿(View Template) 패스포트(Passport) 웹 프레임워크인 익스프레스(Express)가 웹 서버에 필요한 파일들을 자동으로 만들어주기 때문에 익스프레스로 기본 구조를 만들고, 몽고디비(MongoDB)를 이용해서 데이터를 저장하거나 조회할 수 있다. 뷰 탬플릿(View Template)은 클라이언트에 응답을 보낼 때 사용하려고 미리 웹 문서의 원형(Template)을 만들어 놓은 것이며, 패스포트(Passport)는 사용자 로그인이나 회원가입을 위해 사용한다.","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[JS] 이벤트 버블링과 이벤트 캡쳐링","slug":"JS-이벤트-버블링과-캡쳐링","date":"2018-05-16T10:06:13.000Z","updated":"2018-05-16T11:19:54.118Z","comments":true,"path":"2018/05/16/JS-이벤트-버블링과-캡쳐링/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-이벤트-버블링과-캡쳐링/","excerpt":"","text":"Event Bubbling / Event Capturing버블링과 캡쳐링을 본격적으로 알아보기 전에 간단한 코드를 한 번 살펴보자. 1234&lt;div onclick=\"alert('The DIV handler!')\"&gt; DIV 태그 &lt;p&gt;P 태그&lt;/p&gt;&lt;/div&gt; See the Pen Ryewge by SoyeonJung (@je_ss2) on CodePen. div태그에 alert(&#39;The DIV handler!&#39;)라는 이벤트 핸들러를 할당하였고, p태그에는 어떠한 핸들러도 할당하지 않았다. 그런데 p태그를 클릭해도 div태그에 할당된 핸들러가 실행이 된다. 조금 이상하다.p태그를 클릭했는데 왜 div태그에 할당된 핸들러가 실행이 되는 것일까? 버블링 때문이다.자바스크립트의 이벤트 버블링 때문에 위의 코드에서 div태그 안에 있는 p태그를 클릭하면 div태그에 할당된 클릭 이벤트가 발생하는 것이다. 그럼, 버블링이 정확히 뭔데? 이벤트 버블링의 원리는 간단하다. “엘리먼트에 이벤트가 발생하면 먼저 해당 엘리먼트의 핸들러를 실행시킨 후, 그의 부모 엘리먼트의 핸들러를 실행시키고, 또 그 위의 조상 엘리먼트들의 핸들러를 실행시킨다” 마치 버블이 아래에서 위로 올라가는 것과 같아서 버블링이라고 한다. 아래의 예시를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJaNgQ by SoyeonJung (@je_ss2) on CodePen. form태그에는 alert(&#39;form&#39;)클릭 이벤트를 줬고, div태그에는 alert(&#39;div&#39;)클릭 이벤트를 줬고, p태그에는 alert(&#39;p&#39;)클릭 이벤트를 줬다. 그런데, p태그는 div태그가 감싸고 있고, 또 그 div태그는 form태그가 감싸고 있다. 따라서 이벤트 버블링으로 인해, p태그를 클릭하면 p -&gt; div -&gt; form순서로 알림창이 뜬다. 그리고 div태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. p태그를 클릭하면 window에서부터 p태그까지 요소 중간에 있는 이벤트들을 전부 검색해서 따로 메모리에 가지고 있다고 생각하면 된다. 해당 엘리먼트부터 차례대로 위로 올라가면서 이벤트들을 발생시키는 것, 그것이 바로 이벤트 버블링이다. 버블링 멈추기기본적으로 이벤트 버블링은 항상 발생한다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJabwo by SoyeonJung (@je_ss2) on CodePen. form태그와 div태그에만 이벤트 핸들러를 주고, p태그에는 이벤트 핸들러를 주지 않았다. 하지만, 이벤트 버블링으로 인해 p 태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. 이벤트 버블링이 발생되지 않았으면 좋겠어 이벤트 버블링은 event.stopPropagation()을 이용해서 간단하게 멈출 수 있다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"event.stopPropagation()\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen xjyGGK by SoyeonJung (@je_ss2) on CodePen. p태그에 onclick=&quot;event.stopPropagation()&quot;를 주었더니, p태그를 클릭해도 아까처럼 이벤트가 발생하지 않는다. 이벤트 버블링이 작동하지 않기 때문이다. 이벤트 캡쳐링그렇다면 이번에는 이벤트 캡쳐링에 대해서 알아보자. 이벤트 캡쳐링도 이벤트 버블링과 비슷하다. 버블링이 아래에서 위로 올라가는 것이라면, 캡쳐링은 위에서 아래로 내려가는 것이다. addEventListener를 이용하여 버블링과 캡쳐링에 대해서 살펴보자. capturing단계에서 이벤트를 catch하려면 addEventListener의 세 번째 요소를 true로 설정해줘야 한다. 기본적으로 addEventListener의 세 번째 요소를 작성하지 않으면 default값이 false인데, false로 설정할 경우, 핸들러는 버블링 단계로 설정된다. 반면에 true로 설정할 경우, 핸들러는 캡쳐링 단계로 설정된다. 먼저 addEventListener의 세 번째 요소를 작성하지 않았을 경우를 살펴보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName));&#125; See the Pen mLzywJ by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 P -&gt; DIV -&gt; FORM -&gt; BODY -&gt; HTML순서로 알림창이 열린다. addEventListener의 세 번째 요소를 작성하지 않아서 기본값인 false로 되었기 때문에 핸들러가 버블링 단계로 설정되었기 때문이다. 이번에는 addEventListener의 세 번째 요소를 true로 작성해보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName), true);&#125; See the Pen WJabBd by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 HTML -&gt; BODY -&gt; FORM -&gt; DIV -&gt; P순서로 알림창이 열린다. addEventListener의 세 번째 요소를 true로 작성했기 때문에 핸들러가 캡쳐링 단계로 설정되었기 때문이다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 호이스팅(Hoisting)","slug":"JS-호이스팅-Hoisting","date":"2018-05-15T15:43:24.000Z","updated":"2018-05-15T16:19:14.440Z","comments":true,"path":"2018/05/16/JS-호이스팅-Hoisting/","link":"","permalink":"https://jess2.github.io/2018/05/16/JS-호이스팅-Hoisting/","excerpt":"","text":"자바스크립트의 호이스팅(Hoisting)Hoisting이란, 선언을 현재 스크립트 또는 현재 함수의 맨 위로 이동시키는 JavaScript의 기본 동작이다. 만약, 변수가 함수 내에서 정의되었을 경우 선언이 함수 내부의 최상위로 호이스팅되고, 함수 밖에 정의되었을 경우에는 선언이 전역 컨텍스트의 최상위로 호이스팅 된다. 호이스팅 때문에 변수를 선언하기 전에 사용할 수 있다. JavaScript에서는 변수를 선언하기 전에 사용할 수 있다. 아래에 선언을 해도 선언한 것이 Hoisting 되어 위로 끌어올려지기 때문이다. 아래의 Code-1과 Code-2는 동일한 코드라고 보면 된다. Code-1123456x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 var x; // x 선언 Code-212345var x; // x 선언x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 할당은 호이스팅하지 않고, 선언만 호이스팅한다.JavaScript는 Hoisting을 할 때, 선언만 Hoisting하고, 할당은 Hoisting을 하지 않는다. 다음 Code-3과 Code-4는 동일한 코드라고 보면 된다. Code-3123456var x = 5; // x를 선언하고 x에 5를 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined var y = 7; // y를 선언하고 y에 7을 할당 Code-41234567var x = 5; // x를 선언하고 x에 5를 할당var y; // y를 선언 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined y = 7; // y에 7을 할당 위의 Code-3과 Code-4에서 y에 할당된 값인 7이 출력되지 않고 undefined가 출력되는 이유는, 선언만 위쪽으로 끌어 올려지고(Hoisting), 할당은 위로 끌어 올려지지 않기 때문이다. hosting으로 인해 y는 사용되기 전에 선언은 되었지만, 할당이 수행되지 않았기 때문에 y값은 undefined가 되는 것이다. Hosting은 많은 개발자에게 알려지지 않거나 간과 된 JavaScript의 동작인데, 개발자가 Hosting을 이해하지 못하면 프로그램에 버그가 있을 수 있다. 따라서, 버그를 피하려면 항상 모든 범위의 시작 부분에 모든 변수를 선언하고 할당해야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] onclick과 addEventListener 비교","slug":"JS-onclick과-addEventListener-비교","date":"2018-05-15T14:27:19.000Z","updated":"2018-05-15T16:19:39.202Z","comments":true,"path":"2018/05/15/JS-onclick과-addEventListener-비교/","link":"","permalink":"https://jess2.github.io/2018/05/15/JS-onclick과-addEventListener-비교/","excerpt":"","text":"onclick과 addEventListener 비교자바스크립트에서 클릭 이벤트를 줄 때 어떤 방식을 사용하는가?onclick을 사용할 수도, addEventListener를 사용할 수도 있지만, 어떤 것을 사용하든 이 두 가지가 서로 어떻게 다른 지 알고 있어야 한다. onclick은 하나만, addEventListener는 여러 개를. onclick에는 하나의 콜백만 지정할 수 있지만, addEventListener를 사용하면 여러 개의 이벤트 리스너를 추가할 수 있다. 따라서 만약 onclick 이벤트 핸들러를 두 번 이상 사용한다면, 기존 이벤트 핸들러를 덮어쓰기 때문에 가장 아래에 추가한 핸들러만 제대로 작동한다. 반면, addEventListener는 기존 이벤트 핸들러를 덮어 쓰지 않고 얼마든지 계속해서 핸들러를 추가해도 모든 핸들러가 정상적으로 작동한다. 아래의 코드를 보자. ExampleSee the Pen onclick과 addEventListener 비교 by SoyeonJung (@je_ss2) on CodePen. btn에 onclick과 addEventListener 이벤트 핸들러를 각각 두 개씩, 총 네 개의 핸들러를 만들었지만, alert(&#39;onclick-1&#39;)는 실행되지 않고 나머지 세 개만 실행되는 것을 확인할 수 있다. 그럼 onclick은 왜 있는거야?이쯤 되면 이런 의문이 들 수 있다. 클릭 이벤트를 주고 싶으면 그냥 addEventListener를 사용하면 되지, onclick은 굳이 왜 만든 것일까? onclick은 초기 DOM Level-0에서 제공하던 기능이고, 그 이후 버전인 Level-2에서 추가된 것이 addEventListener이다. addEventListener는 이벤트 캡쳐링, 버블링 같은 이벤트 방식을 설정할 수 있기 때문에 이벤트 제어에 있어서 더욱 유용하지만, addEventListener는 IE8 이하에서는 작동을 하지 않는다. 그래서 구형 브라우저 지원이 필요하면 onclick을 사용하거나 다른 방법을 찾아야 한다.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]}]}