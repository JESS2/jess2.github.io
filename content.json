{"meta":{"title":"Jess2's IT Blog","subtitle":"제씨의 기술블로그","description":null,"author":"Jess2","url":"https://jess2.github.io"},"pages":[],"posts":[{"title":"[JAVA] 일반 배열에 특정 값이 들어있는 지 확인하기","slug":"Java/JAVA-일반-배열에-특정-값이-들어있는-지-확인하기","date":"2018-08-06T08:38:42.000Z","updated":"2018-08-06T08:42:32.000Z","comments":true,"path":"2018/08/06/Java/JAVA-일반-배열에-특정-값이-들어있는-지-확인하기/","link":"","permalink":"https://jess2.github.io/2018/08/06/Java/JAVA-일반-배열에-특정-값이-들어있는-지-확인하기/","excerpt":"","text":"일반 배열에 특정 값이 들어있는 지 확인하기방법 1) asList / contains 사용1Arrays.asList(array).contains(value); 방법 2) equals 사용12345for(String s: arr)&#123; if(s.equals(targetValue)) return true;&#125;return false;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Java","slug":"BackEnd/Java","permalink":"https://jess2.github.io/categories/BackEnd/Java/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Java","slug":"Java","permalink":"https://jess2.github.io/tags/Java/"}]},{"title":"[Java] 문자열 뒤집기","slug":"Java/Java-문자열-뒤집기","date":"2018-06-13T14:41:46.000Z","updated":"2018-06-13T14:45:34.000Z","comments":true,"path":"2018/06/13/Java/Java-문자열-뒤집기/","link":"","permalink":"https://jess2.github.io/2018/06/13/Java/Java-문자열-뒤집기/","excerpt":"","text":"문자열 뒤집기StringBuffer클래스의 reverse()메소드를 사용하여 문자열의 순서를 반대로 뒤집을 수 있다. ex) hello -&gt; olleh Example1234567891011public class TestClass &#123; public static void main(String[] args) &#123; String str = \"ABCDE 안녕하세요\"; System.out.println(reverseStr(str)); // 출력 결과 : 요세하녕안 EDCBA &#125; public static String reverseStr(String s) &#123; return (new StringBuffer(s)).reverse().toString(); &#125;&#125;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Java","slug":"BackEnd/Java","permalink":"https://jess2.github.io/categories/BackEnd/Java/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Java","slug":"Java","permalink":"https://jess2.github.io/tags/Java/"}]},{"title":"[Java] String -> int, int-> String 형변환","slug":"Java/Java-String-int","date":"2018-06-13T14:41:46.000Z","updated":"2018-08-06T08:42:32.000Z","comments":true,"path":"2018/06/13/Java/Java-String-int/","link":"","permalink":"https://jess2.github.io/2018/06/13/Java/Java-String-int/","excerpt":"","text":"String -&gt; int, int-&gt; String 형변환1) String -&gt; int 형변환1Integer.parseInt(str); 2) int -&gt; String 형변환1String.valueOf(numInt); 123456789101112131415public class TestClass &#123; public static void main(String[] args) &#123; String str = \"1\"; // String -&gt; int 형변환 int numInt = Integer.parseInt(str); System.out.println(numInt + 1); // 출력 결과 : 2 // int -&gt; String 형변환 String numStr = String.valueOf(numInt); System.out.println(numStr + 1); // 출력결과 : 11 &#125;&#125;","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Java","slug":"BackEnd/Java","permalink":"https://jess2.github.io/categories/BackEnd/Java/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Java","slug":"Java","permalink":"https://jess2.github.io/tags/Java/"}]},{"title":"[ES6] Class","slug":"ECMAScript6/ES6-Class","date":"2018-06-12T10:53:42.000Z","updated":"2018-06-12T11:12:04.000Z","comments":true,"path":"2018/06/12/ECMAScript6/ES6-Class/","link":"","permalink":"https://jess2.github.io/2018/06/12/ECMAScript6/ES6-Class/","excerpt":"","text":"ECMAScript 2015의 ClassES6에 변수에 대한 규칙이 엄격해지고 클래스와 모듈 같은 복잡한 응용 프로그램을 작성하기 위한 새로운 문법이 추가되었다. 특히 명시적인 클래스의 추가로 더욱 더 편리해졌다. 기본의 자바스크립트(ES5)에는 클래스가 없어서, 생성자 함수와 프로토타입으로 클래스의 개념을 구현했지만, ES6에서는 클래스를 선언할 수 있다. ES5와 ES6의 코드를 비교해보자. ES5 Example12345678910111213141516//생성자 함수function Character(name, job) &#123; this.name = name; this.job = job;&#125; //프로토타입으로 메소드 생성Character.prototype.move = function() &#123; document.write(this.name + ' ' + this.job + ' 캐릭터 이동&lt;br&gt;');&#125; //인스턴스 객체 생성var char1 = new Character('루이스', '기사'); //메소드 실행char1.move(); ES6 Example12345678910111213141516//클래스 선언class Character&#123; constructor(name, job) &#123; this.name = name; this.job = job; &#125; move() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br&gt;`); &#125;&#125; //인스턴스 객체 생성let char1 = new Character('루이스', '기사'); //메소드 실행char1.move(); (줄 2) : 생성자 함수로 정의하던 형태로 constructor에 속성을 정의한다. (줄 7) : 메소드를 지정한다. 클래스 내의 함수들은 function키워드를 따로 선언하지 않아도 된다. 기존 방식에서는 prototype으로 함수들을 별도로 선언해서 연결하는 방식이어서 구성이 복잡하였지만, ES6에서는 문법이 간결해졌다. Class의 상속클래스의 상속이란, 클래스 원형을 토대로 새로운 클래스를 재창조하는 것이다. ES6의 클래스를 사용하면 기존 자바스크립트로 클래스의 상속 개념을 구현하는 것보다 작업이 훨씬 간단해진다. ES6 Example1234567891011121314151617181920212223242526272829303132'use strict'; //문법을 엄격하게 적용함 // 클래스 선언class Character &#123; constructor(name, job) &#123; this.name = name; this.job = job; &#125; move() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br&gt;`); &#125;&#125; //자식 클래스class Monster extends Character &#123; constructor(name, job, skill) &#123; super(name, job); this.skill = skill; &#125; useSkill() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; $&#123;this.skill&#125; 스킬 사용&lt;br&gt;`); &#125;&#125; //인스턴스 객체 생성let char1 = new Character('루이스', '기사');let monster = new Monster('오크', '대장', '몽둥이'); //메소드 실행char1.move(); //루이스 기사 캐릭터 이동monster.useSkill(); //오크 대장 몽둥이 스킬 사용monster.move(); //오크 대장 캐릭터 이동 (줄 17) : super()는 상속받은 부모의 생성자(constructor)를 호출해 자식 클래스인 Monster에 적용한다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"ECMAScript6","slug":"FrontEnd/ECMAScript6","permalink":"https://jess2.github.io/categories/FrontEnd/ECMAScript6/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/tags/ECMAScript6/"}]},{"title":"[Node] 스트림(Stream)","slug":"Node.js/Node-스트림-Stream","date":"2018-06-08T11:20:45.000Z","updated":"2018-06-08T14:20:28.000Z","comments":true,"path":"2018/06/08/Node.js/Node-스트림-Stream/","link":"","permalink":"https://jess2.github.io/2018/06/08/Node.js/Node-스트림-Stream/","excerpt":"","text":"스트림(Stream)스트림은 배열이나 문자열같은 데이터 컬렉션이다. 스트림은 대용량의 파일을 다룰 때나, 외부 소스로부터 데이터를 한번에 일부분씩 가져올때 사용된다. 스트림이 왜 필요한데? fs 모듈을 사용하면 파일을 읽고 쓸 수 있다. 그러나 파일이 대용량일 경우, 파일 전체를 모두 로드하기 전에 메모리 버퍼를 절약하기 위해 뭔가를 해야할 때가 있다. 그래서 파일의 일부분씩만 가져올 때 Stream이 필요하다. 읽기 스트림 : createReadStream읽기 스트림은 data, end, error이벤트를 가진 EventEmitter이다. 종류 설명 data 파일의 일부를 리턴한다. end 읽기가 완료되었을 때 호출된다. error 에러가 발생했을 때 호출된다. Example1234567891011121314var fs = require('fs'); //fs 모듈var stream = fs.createReadStream('./bigfile');stream.on('data', function(data) &#123; console.log('loaded part of the file');&#125;);stream.on('end', function() &#123; console.log('all parts is loaded');&#125;);stream.on('error', function(err) &#123; console.log('something is wrong');&#125;); 쓰기 스트림 : createWriteStream인터넷에서 파일을 요청하고 데이터의 일부를 받을 때마다 파일에 쓰는 예제를 살펴보자. Example123456789101112131415161718var fs = require('fs');var request = require('request');var stream = request('http://i.imgur.com/dmetFjf.jpg');var writeStream = fs.createWriteStream('test.jpg');stream.on('data', function(data) &#123; writeStream.write(data);&#125;);stream.on('end', function() &#123; writeStream.end();&#125;);stream.on('error', function(err) &#123; console.log('something is wrong'); writeStream.close();&#125;); pipepipe는 입력을 출력으로 리다이렉트 할 수 있게 해주는 또 다른 개념이다. 위의 쓰기 스트림 예제를 아래와 같이 pipe로 표현할 수 있다. Example1234567var fs = require('fs');var request = require('request');var stream = request('http://i.imgur.com/dmetFjf.jpg');var writeStream = fs.createWriteStream('test.jpg');stream.pipe(writeStream); pipe는 stream간에 read와 write event들을 연결해주기 때문에 여러 개의 pipe를 서로 연결할 수도 있다. Example123456789var fs = require('fs');var request = require('request');var gzip = require('zlib').createGzip();var stream = request('http://i.imgur.com/dmetFjf.jpg');var writeStream = fs.createWriteStream('test.jpg');//write gzipped image filestream.pipe(gzip).pipe(writeStream); Readable 스트림Readable Stream은 데이터를 읽을 때 읽는 타이밍이나 한 번에 얼마나 읽을지를 제어할 수 있게 해준다. 다음은 Readable 스트림 객체가 제공하는 함수이다. 함수 설명 read([size]) 스트림에서 String이나 Buffer, null형태의 데이터를 읽음. size전달 인자를 지정한 경우 읽는 데이터의 크기가 제한됨. setEncoding(encoding) read()요청 결과를 String형태로 반환 시 인코딩 형태. pause() 객체에서 생성되는 data이벤트를 중지. resume() 객체에서 생성되는 data이벤트를 재개. pipe(destination, [options] 출력 스트림을 destination 필드에 지정된 Writable 스트림 객체에 연결. {end:true}는 Readable이 끝나는 시점에 Writable 목적 스트림도 끝나는 것을 의미. unpipe([destination]) Writable 목적 스트림에서 객체 제거 Example12345678910111213var fs = require('fs');var stream = fs.createReadStream('test1.jpg');var writeStream = fs.createWriteStream('test2.jpg');stream.on('readable', fuction() &#123; //stream이 읽을 준비가 됨 var data = stream.read(); writeStream.write(data);&#125;);stream.on('end', function() &#123; writeStream.end();&#125;); stream.read()로 데이터를 읽는 것을 제어할 수 있다. 만약 데이터를 읽을 수 없다면, readable 이벤트는 다시 이벤트 루프에 던져지고 나중에 다시 걸리게 될 것이다. Writable 스트림Writable Stream은 새로운 drain이벤트가 추가되었는데, 이 이벤트는 buffer에 있는 모든 데이터가 쓰여졌을 때 걸리게 된다. 이를 통해서 buffer가 비워졌을 때 데이터를 쓸 수 있도록 타이밍을 제어할 수 있다. 다음은 Writable 스트림 객체 상에서 사용 가능한 함수이다. 함수 설명 write(chunk, [encoding], [callback]) 스트림 객체의 데이터 위치에 데이터 청크를 쓴다. 데이터는 String이나 Buffer형태다. encoding이 지정되면 문자열 데이터의 인코딩 정보로 사용된다. callback이 지정되면 데이터가 비워진 이후 호출된다. end(chunk, [encoding], [callback]) 데이터를 더 이상 수용하지 않고 finish이벤트를 보내는 것을 제외하면 write()와 동일하다. Example12345678910111213141516171819202122232425var fs = require('fs');var stream = fs.createReadStream('./input.jpg');var writeStream = fs.createWriteStream('./output.jpg');var writable = true;var doRead = function() &#123; var data = stream.read(); //만약 writable이 false를 리턴한다면, buffer가 꽉 차있다는 뜻임. writable = writeStream.write(data);&#125;stream.on('readable', function() &#123; if(writable) &#123; doRead(); &#125; else &#123; //streambuffer가 꽉 찼으니 drain 이벤트가 발생할 때까지 대기 writeStream.removeAllListeners('drain'); writeStream.once('drain', doRead); &#125;&#125;);stream.on('end', function() &#123; writeStream.end();&#125;);","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Node.js","slug":"BackEnd/Node-js","permalink":"https://jess2.github.io/categories/BackEnd/Node-js/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[JS] 로컬 스토리지(LocalStorage)","slug":"JavaScript/JS-로컬-스토리지-Local-Storage","date":"2018-06-06T11:09:10.000Z","updated":"2018-06-06T13:19:10.000Z","comments":true,"path":"2018/06/06/JavaScript/JS-로컬-스토리지-Local-Storage/","link":"","permalink":"https://jess2.github.io/2018/06/06/JavaScript/JS-로컬-스토리지-Local-Storage/","excerpt":"","text":"스토리지(Storage)자바스크립트 개발을 하다보면 스토리지가 필요할 때가 있다. 스토리지에 대해 알아보자. HTML5에서 추가된 로컬 스토리지는 window 객체의 하위 객체로, 영구 저장인 로컬 스토리지와 브라우저 실행 중에만 유효한 세션 스토리지라는 두 가지 저장 방식을 제공한다. 스토리지 종류 구분 유효기간 localStorage 없음(영구적) sessionStorage 브라우저 탭이 열려 있는 동안만 유효하며 종료 시 삭제됨 로컬 스토리지와 세션 스토리지는 유효 기간 외에는 사용하는 데 큰 차이가 없으므로 로컬 스토리지에 대해 알아보자. key와 value로컬 스토리지의 저장은 키와 값의 형태로 이루어진다. 키는 저장된 값을 식별하고 가져오는 데 사용되고 원하는 만큼 로컬 스토리지에 키를 저장할 수 있다. 반대로 키를 가져올 때는 조회하려는 키 값으로 요청한다. 할당된 키에 저장되는 값은 숫자, 문자열 또는 객체(JSON)나 배열 같은 형태로 저장할 수 있다. 데이터 저장 및 조회하기데이터를 저장하고 조회하기 위해 사용되는 메서드와 속성을 정리해 보고 예시를 살펴보자. 로컬 스토리지 메서드 및 속성 이름 구분 쿠키 setItem(key, value) 메서드 해당 키 값으로 데이터를 저장한다. getItem(key) 메서드 해당 키 값의 이름을 가진 데이터를 가져온다. removeItem(key) 메서드 해당 키 값의 이름을 가진 데이터를 삭제한다. key(index) 메서드 해당 인덱스 값을 가진 키의 이름을 가져온다. clear() 메서드 모든 데이터를 삭제한다. length 속성 저장된 데이터 수를 가져온다. 인터넷 익스플로러에서 테스트 시 주의할 점인터넷 익스플로러의 경우 로컬 실행 환경에서 스토리지 기능이 작동하지 않는다. 반드시 서버 실행 환경에서 URL로 지정해야만 확인할 수 있으므로 주의해야 한다. 데이터 저장 및 조회123456// 저장localStorage.setItem('name', 'jess2');// 조회var getValue = localStorage.getItem('name');console.log(getValue); // jess2 로컬 스토리지에 name이라는 키 값으로 jess2라는 값을 저장한 다음 다시 저장한 키 값으로 데이터를 조회한다. 크롬 개발자 도구의 스토리지 확인크롬 개발자 도구에서 Application탭을 클릭하면 Storage &gt; Local Storage에 저장한 데이터의 키와 값을 확인할 수 있다. 데이터 삭제도 다음과 같이 removeItem()메서드로 간단하게 처리할 수 있다. 1localStorage.removeItem('name'); 사용자 환경 설정 구현하기애플리케이션을 실행할 때 서버에 저장하지 않아도 되는 환경 설정을 로컬 스토리지에 저장하면 편리할 뿐만 아니라 서버와의 통신할 필요가 없으므로 성능상으로도 이점이 있다. 다음은 글상자 속의 글자색과 배경색을 저장하고 다시 불러오는 예제이다. 주요 선택자와 속성 변경 부분은 제이쿼리로 작성했다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;body&gt; &lt;textarea name=\"txt\" id=\"txt\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;br/&gt; &lt;label for=\"textcolor\"&gt;change text color&lt;/label&gt; &lt;input type=\"color\" id=\"textcolor\"/&gt;&lt;br/&gt; &lt;label for=\"bgcolor\"&gt;change bg color&lt;/label&gt; &lt;input type=\"color\" id=\"bgcolor\"/&gt;&lt;br/&gt; &lt;button id=\"set_color\"&gt;set color&lt;/button&gt; &lt;!--색상 설정 저장 버튼--&gt; &lt;button id=\"get_color\"&gt;get color&lt;/button&gt; &lt;!--색상 설정 읽기 버튼--&gt; &lt;script&gt; //글 상자에 글자를 입력 $('#txt').val('글상자 영역의 색상 값을 저장합니다.'); //글자색 변경 시 글상자의 글자색에 적용 $('#textcolor').change(function()&#123; var color = $(this).val(); $('#txt').css('color', color); &#125;); //배경색 변경시 글상자의 배경색에 적용 $('#bgcolor').change(function()&#123; var color = $(this).val(); $('#txt').css('backgroundColor', color); &#125;); //글자색과 배경색을 로컬 스토리지에 저장 $('#set_color').click(function()&#123; var bgcolor = $('#bgcolor').val(); var textcolor = $('#textcolor').val(); var obj = &#123; bgcolor : bgcolor, textcolor : textcolor &#125; localStorage.setItem('color', JSON.stringify(obj)); &#125;); //로컬 스토리지에 저장한 환경 설정을 읽어 오기 $('#get_color').click(function()&#123; var color = JSON.parse(localStorage.getItem('color')); $('#txt').css(&#123; 'backgroundColor' : color.bgcolor, 'color' : color.textcolor &#125;); &#125;); &lt;/script&gt;&lt;/body&gt; (줄 15~19) : color picker 입력 요소를 통해 색상이 변경되면 텍스트 영역의 색상이 변경되도록 한다. (줄 27~36) : 현재 컬러 입력 요소(글자색과 배경색)에 지정된 색상 값을 val()메서드로 읽어서 각각의 키 값(bgcolor, textcolor)을 지정해 로컬 스토리지에 저장한다. (줄 31~35) : 자바스크립트에서는 데이터를 외부(웹 스토리지나 서버 등)와 주고받는 경우 JSON표준 형식을 이용한다. 데이터를 내보낼 경우에는 먼저 데이터를 문자열(string)로 변환해 주어야 한다. 따라서 객체 형태의 데이터를 스트링으로 변환하기 위해 JSON.stringify()메서드를 사용해 문자열로 변환시켜 저장한다. (줄 38~45) : 환경 설정으로 저장한 로컬 스토리지의 키 값으로 글상자 #txt의 색상 값을 읽어 와 다시 글상자에 스타일로 적용한다. (줄 40) : JSON.parse()를 이용해 문자열을 객체로 변환하여 가져온다. 이러한 형식은 자바스크립트 뿐만 아니라 독립적인 데이터 포맷(JSON)으로 다양한 프로그래밍 언어에서 표준(AJAX 통신)으로 사용된다. 실행결과See the Pen yEJRdO by SoyeonJung (@je_ss2) on CodePen. 색상을 선택한 뒤 set color를 클릭하면 로컬스토리지에 선택한 색상이 저장된다. 새로고침을 하거나 색상을 변경한 뒤에 get color를 클릭하면 로컬 스토리지에 저장되었던 색상을 읽어온다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] DOM","slug":"JavaScript/JS-DOM","date":"2018-06-01T14:33:17.000Z","updated":"2018-06-01T15:45:34.000Z","comments":true,"path":"2018/06/01/JavaScript/JS-DOM/","link":"","permalink":"https://jess2.github.io/2018/06/01/JavaScript/JS-DOM/","excerpt":"","text":"DOM : 문서를 동적으로 다루는 방법자바스크립트로 문서 객체(DOM)을 조작할 수 있다. 그렇다면 DOM이란 무엇일까? 문서 객체 모델(Document Object Model, DOM)은 HTML 및 XML 문서를 처리하는 API이다. 문서의 구조적 형태를 제공하므로 자바스크립트(JavaScript)와 같은 스크립트 언어를 사용하여 문서 내용과 시각적 표현을 수정할 수 있다. DOM 메서드 메서드 설명 document.getElementById(id명) 아이디를 사용해 문서 객체(요소) 선택 document.querySelector(CSS 선택자) CSS 선택자를 사용하는 방식(IE 8 이상) document.getElementsByTagName(태그명) 태그명으로 여러 문서 객체 선택 document.getElementsByClassName(클래스명) 클래스명으로 여러 문서 객체 선택(IE 9 이상) document.querySelectorAll(CSS 선택자) CSS 선택자로 여러 문서 객체 선택(IE 9 이상) 1. getElementById : id명을 사용하는 방식이 메서드는 요소에 접근하는 가장 빠른 방식으로, 하나의 요소만 선택하는 방식이다. 123456789&lt;h1 id=\"title\"&gt;여기를 변경해주세요.&lt;/h1&gt;&lt;script&gt; var title = document.getElementById('title'); title.style.color = 'white'; title.style.background = 'orange'; title.innerHTML = \"JavaScript로 문서를 조작\";&lt;/script&gt; 실행결과See the Pen xzwwPx by SoyeonJung (@je_ss2) on CodePen. html 문서 내에서 id명이 title인 문서 객체를 선택하고 JavaScript에서 title변수에 반영한 후 문서 객체 스타일을 변경하는 등 문서를 조작한다. 2. querySelector : CSS 선택자를 사용하는 방식CSS 선택자를 사용하는 방식은 편리하지만 가장 첫 번쨰 요소만 선택할 수 있다. 1234567891011&lt;li&gt;first&lt;/li&gt;&lt;ul&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var li = document.querySelector('ul &gt; li'); li.style.color = \"red\";&lt;/script&gt; 실행결과See the Pen rKOxpM by SoyeonJung (@je_ss2) on CodePen. 3. getElementsByTagName : 태그명으로 여러 문서 객체 선택태그명으로 문서 객체를 선택하는 방식이다. 태그는 문서 내에서 중복 사용할 수 있으므로 작성한 만큼 배열로 판단한다. 123456789101112131415&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var li = document.getElementsByTagName('li'); for(var i=0; i&lt;li.length; i++) &#123; li[i].style.color = \"red\"; &#125; li[1].style.background = \"blue\";&lt;/script&gt; 실행결과See the Pen ZRbbmd by SoyeonJung (@je_ss2) on CodePen. 4. getElementsByClassName : 클래스명으로 여러 문서 객체 선택클래스명으로 문서 객체를 선택하는 방식이다. 클래스는 문서 내에서 중복 사용할 수 있으므로 작성한 만큼 배열로 판단한다. 123456789101112131415161718&lt;div class=\"select\"&gt; 선택된 문서 객체&lt;/div&gt;&lt;div&gt; 선택되지 않은 문서 객체&lt;/div&gt;&lt;div class=\"select\"&gt; 선택된 문서 객체2&lt;/div&gt;&lt;script&gt; var selects = document.getElementsByClassName('select'); selects[0].style.color = \"red\"; selects[1].style.color = \"blue\";&lt;/script&gt; 실행결과See the Pen XYmmvb by SoyeonJung (@je_ss2) on CodePen. 5. querySelectorAll : CSS 선택자로 여러 문서 객체 선택CSS 선택자로 여러 문서 객체를 선택할 수 있다. 12345678910111213141516&lt;div&gt; &lt;span&gt;first in \"p\"&lt;/span&gt;&lt;/div&gt;&lt;span&gt;second&lt;/span&gt;&lt;div&gt; &lt;span&gt;third in \"p\"&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var span = document.querySelectorAll('div &gt; span'); for(var i=0; i&lt;span.length; i++) &#123; span[i].style.color = \"red\"; &#125;&lt;/script&gt; 실행결과See the Pen OEyMga by SoyeonJung (@je_ss2) on CodePen.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 배열 메서드","slug":"JavaScript/JS-배열-메서드","date":"2018-06-01T12:47:01.000Z","updated":"2018-06-01T14:15:36.000Z","comments":true,"path":"2018/06/01/JavaScript/JS-배열-메서드/","link":"","permalink":"https://jess2.github.io/2018/06/01/JavaScript/JS-배열-메서드/","excerpt":"","text":"자바스크립트 배열 메서드Javascript Array 클래스에 정의되어있는 배열 메서드에 대하여 알아보자. 메서드 설명 reverse() 배열을 역순으로 정렬 sort() 배열 정렬 slice() 배열의 일부 선택 concat() 배열을 하나로 합침 shift() 첫 번째 배열 제거(제거한 값을 반환함) unshift() 첫 번째 배열 추가 pop() 마지막 배열 제거(제거한 값을 반환함) join() 지정된 문자열로 배열 사이 구분자 표시 1. reverse() : 배열을 역순으로 정렬reverse메서드로 배열을 역순으로 변경할 수 있다. 원래 배열의 순서가 실제로 변경된다. 1234var array = [16, 33, 42, 53, 11];document.write(array.reverse() + '&lt;br&gt;'); // 11,53,42,33,16document.write(array); // 11,53,42,33,16 2. sort() : 배열 정렬sort메서드로 데이터를 숫자, 알파벳 또는 가나다순으로 정렬할 수 있고 원래 배열의 순서가 실제로 변경된다. sort메서드의 매개 변수에 함수식을 적용하여 오름차순으로 정렬할지, 내림차순으로 정렬할지 설정할 수 있다. 12345678910111213141516171819var scores = [90, 55, 80, 60, 100];var names = [ \"Michael Kwon\", \"Steve Jobs\", \"John Denver\", \"Pokemon\"];//배열을 알파벳 순으로 정렬document.write(names.sort() + '&lt;br&gt;'); // John Denver,Michael Kwon,Pokemon,Steve Jobs//배열을 번호 순으로 정렬document.write(scores.sort() + '&lt;br&gt;'); // 100,55,60,80,90//오름차순, 내림차순 설정하여 정렬document.write(scores.sort(function(a, b)&#123; return a - b; &#125;) + '&lt;br&gt;'); // 55,60,80,90,100document.write(scores.sort(function(a, b)&#123; return b - a; &#125;) + '&lt;br&gt;'); // 100,55,60,80,90document.write(scores + '&lt;br&gt;'); // 100,55,60,80,90 추가적으로 알게된 사실위의 예시 코드에서 names를 name으로 변경하면 Uncaught TypeError: name.sort is not a function에러가 발생한다. names.sort는 가능하지만 name.sort는 불가능한 이유가 무엇일까? window 객체에 이미 name이라는 변수가 존재하는데, 브라우저 스펙상 해당 변수의 타입은 string으로 유지된다. 따라서 TypeError가 발생하는 것이다. 3. slice() : 배열의 일부 선택slice메서드는 배열의 특정 범위를 추출하고, 실제 배열을 변경시키진 않는다. 특정 범위를 선택하는 방법은 첫 번째 매개변수를 시작 인덱스로 설정해주고, 두 번째 매개변수를 마지막 인덱스에 1을 더한 값으로 설정해주면 된다. 1234var str = ['apple', 'banana', 'orange', 'grapes', 'melon'];document.write(str.slice(1, 3) + '&lt;br&gt;'); // banana,orangedocument.write(str + '&lt;br&gt;'); // apple,banana,orange,grapes,melon 4. concat() : 배열 합치기concat메서드는 배열과 배열을 연결해 하나의 배열로 합친다. 그러나 원래 배열이 실제로 변경되지는 않는다. 12345678910var korea = ['서울', '부산', '광주'];var japan = ['도쿄', '오사카'];var usa = ['워싱턴', '뉴욕'];var world = korea.concat(japan);document.write(korea + '&lt;br&gt;'); // 서울,부산,광주document.write(world + '&lt;br&gt;'); // 서울,부산,광주,도쿄,오사카var world = korea.concat(japan, usa);document.write(world); // 서울,부산,광주,도쿄,오사카,워싱턴,뉴욕 5. shift(), unshift() : 첫 번째 배열 제거 및 추가하기첫 번째 배열을 제거할 때는 shift메서드를 사용한다. shift메서드는 제거한 값을 반환한다. 그리고 첫 번째 배열에 데이터를 추가할 때는 unshift메서드를 사용한다. shift와 unshift는 원본 배열을 변경시킨다. 123456789var korea = ['서울', '부산', '광주'];//shiftdocument.write(korea.shift() + '&lt;br&gt;'); // 서울document.write(korea + '&lt;br&gt;'); // 부산,광주//unshiftkorea.unshift('제주도');document.write(korea + '&lt;br&gt;'); // 제주도,부산,광주 6. pop() : 마지막 배열 제거하기pop메서드는 shift메서드와 반대로 배열의 마지막 부분을 제거한 후 그 값을 반환한다. 따라서 원본 배열을 변경시킨다. 12345var nums = [1, 2, 3, 4, 5];//popdocument.write(nums.pop() + '&lt;br&gt;'); // 5document.write(nums + '&lt;br&gt;'); // 1,2,3,4 7. join() : 지정된 문자열로 배열 사이 구분자 표시join메서드는 배열을 구분하는 문자를 기본 쉼표에서 특정한 문자로 변경하여 표시할 수 있다. 그러나 원본 배열 내용을 변경하는 것은 아니다. 12345var age = [23, 44, 12, 32, 5];//joindocument.write(age.join(' - ') + '&lt;br&gt;'); // 23 - 44 - 12 - 32 - 5document.write(age); // 23,44,12,32,5","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[React] Props","slug":"React/React-Props","date":"2018-05-30T14:14:34.000Z","updated":"2018-05-30T15:46:04.000Z","comments":true,"path":"2018/05/30/React/React-Props/","link":"","permalink":"https://jess2.github.io/2018/05/30/React/React-Props/","excerpt":"","text":"PropsProps는 컴포넌트 내부의 Immutable Data(변화하지 않는 데이터)를 처리할 때 사용된다. JSX내부에 { this.props.propsName }이 있을 때, 컴포넌트를 렌더링할 때 propsName = &quot;value&quot;이런 식으로 전달하면 된다. 아래의 예제를 보자. index.js12345import React from 'react';import ReactDOM from 'react-dom';import PropsTest from './PropsTest';ReactDOM.render(&lt;PropsTest name=\"jessie\" /&gt;, document.getElementById('root')); index.js파일의 PropsTest확장 태그에 name=&quot;jessie&quot; 애트리뷰트를 추가했다. PropsTest.js123456789101112import React from 'react';export default class PropsTest extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello &#123; this.props.name &#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; PropsTest확장 태그를 구현한 PropsTest클래스에서 애트리뷰트 값을 사용하기 위한 표현식은 { this.props.[애트리뷰트이름] }이다. index.js파일에서 name이라는 애트리뷰트를 추가했기 때문에 PropsTest.js파일에서 { this.props.name }이라고 작성하면 된다. 실행결과 this.props.childrenthis.props.childeren은 기본적으로 갖고있는 props로써, 별도의 props이름 설정 없이 값을 설정할 수 있다. 아래의 예시를 보자. index.js12345import React from 'react';import ReactDOM from 'react-dom';import PropsTest from './PropsTest';ReactDOM.render(&lt;PropsTest name=\"jessie\"&gt;I love React!!!&lt;/PropsTest&gt;, document.getElementById('root')); index.js파일의 PropsTest확장 태그 사이에 별도의 애트리뷰트 이름 없이 I love React!!!라는 문구를 작성했다. PropsTest.js12345678910111213import React from 'react';export default class PropsTest extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello &#123; this.props.name &#125;&lt;/h1&gt; &lt;h2&gt;&#123; this.props.children &#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 애트리뷰트 값을 사용하기 위한 표현식은 { this.props.children }이다. 실행결과 defaultProps - props 기본값 설정컴포넌트 설정이 끝난 후, defaultProps객체를 설정하면 된다. 아래의 예제는 name props의 기본값을 ellie로 설정하고 있다. index.js12345import React from 'react';import ReactDOM from 'react-dom';import PropsTest from './PropsTest';ReactDOM.render(&lt;PropsTest&gt;I love React!!!&lt;/PropsTest&gt;, document.getElementById('root')); index.js파일의 PropsTest확장 태그에 추가했던 name=&quot;jessie&quot;애트리뷰트를 삭제했다. 따라서 현재 설정된 name애트리뷰트는 없다. PropsTest.js1234567891011121314151617import React from 'react';export default class PropsTest extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello &#123; this.props.name &#125;&lt;/h1&gt; &lt;h2&gt;&#123; this.props.children &#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;PropsTest.defaultProps = &#123; name: 'ellie'&#125;; PropsTest.js파일에서 defaultProps객체를 설정해주었다. name props의 기본값을 ellie로 설정했다. 이렇게 되면, index.js파일에서 별도의 애트리뷰트를 설정하지 않았을 때 기본값으로 name에 ellie가 들어가는 것이다. 실행결과 PropTypes - 애트리뷰트 값 타입 지정이 기능을 통하여 특정 props값이 특정 type이 아니거나 필수 props인데 입력하지 않았을 경우 경고를 띄울 수 있다. Type을 검증할 때는 Component선언이 끝난 후, PropTypes를 설정하면 된다. 단, React v15.5부터 PropTypes가 React에서 분리되었기 때문에 import를 꼭 해줘야 한다.1import PropTypes from 'prop-types'; 그럼 아래의 예시를 보자. PropsTest.js12345678910111213141516171819202122import React from 'react';import PropTypes from 'prop-types';export default class PropsTest extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello &#123; this.props.name &#125;&lt;/h1&gt; &lt;h2&gt;&#123; this.props.children &#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;PropsTest.defaultProps = &#123; name: 'ellie'&#125;;PropsTest.propTypes = &#123; name: PropTypes.number&#125;; 21번 줄에서 name애트리뷰트 값 타입을 number로 지정했다. 그런데, name에 지정한 값의 타입은 string이기 때문에 아래와 같이 에러가 발생한다. Warning: Failed prop type: Invalid prop name of type string supplied to Props, expected number. 또한, 타입 지정 뒤에 isRequired를 붙여주면 이 애트리뷰트가 필수로 입력이 되도록 설정할 수 있다. propTypes를 아래와 같이 수정해보자. 1234PropsTest.propTypes = &#123; name: PropTypes.string, age: PropTypes.number.isRequired&#125;; name애트리뷰트 값 타입을 string으로 지정해주었기 때문에 이 부분에서는 더 이상 에러가 발생하지 않는다. 하지만 age애트리뷰트 값 타입 지정 뒤에 isRequired를 붙여주었기 때문에 age애트리뷰트가 필수로 있어야 한다. 그런데 age애트리뷰트를 설정하지 않으면 아래와 같이 에러가 발생한다. Warning: Failed prop type: The prop age is marked as required in Props, but its value is undefined. PropTypes 종류 타입 지정 설명 PropTypes.string 문자열 PropTypes.array 배열 PropTypes.bool true/false PropTypes.func 자바스크립트 함수 PropTypes.number 숫자 PropTypes.object 객체 PropTypes.symbol 자바스크립트 symbol PropTypes.instanceOf(클래스명) 클래스 객체 PropTypes.oneOf([‘값1’, ‘값2’]) 두 값 중 하나 PropTypes.arrayOf(PropTypes.number) 숫자 배열 어떤 타입이든 필수로 입력이 되도록 설정하기타입 지정 뒤에 isRequired를 붙여주면 된다. : PropTypes.any.isRequired","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"React.js","slug":"FrontEnd/React-js","permalink":"https://jess2.github.io/categories/FrontEnd/React-js/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"React.js","slug":"React-js","permalink":"https://jess2.github.io/tags/React-js/"}]},{"title":"[React] JSX의 특징","slug":"React/React-JSX","date":"2018-05-30T13:17:40.000Z","updated":"2018-05-30T16:03:32.000Z","comments":true,"path":"2018/05/30/React/React-JSX/","link":"","permalink":"https://jess2.github.io/2018/05/30/React/React-JSX/","excerpt":"","text":"JSX의 특징이전 포스팅에서 JSX에 대해 잠깐 다뤄보았지만, 본격적으로 자세하게 알아보자. 모든 리액트 컴포넌트는 render메소드가 있는데 이것은 컴포넌트가 어떻게 생길지 정의해준다. 여기서 특별한 점 하나는 JSX다. 이것은 자바스크립트 코드에서 html형식을 그대로 사용할 수 있게 해준다. 그리고 React JSX는 XML같은 문법을 Native JavaScript로 변환해준다. render메소드 안에서 어떤 뷰를 보여줄 지 JSX형태로 리턴하면 된다. 그렇다면 이제 JSX의 특징에 대해서 자세히 알아보자. 특징1. Nested Element모든 JSX형태의 코드는 container element안에 포함시켜줘야 한다. 아래의 예시를 보자. Example1234567891011121314151617//에러render() &#123; return ( &lt;h1&gt;Hi&lt;/h1&gt; &lt;h2&gt;I am Error&lt;/h2&gt; );&#125;//container element 안에 포함시켜야 한다.render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hi&lt;/h1&gt; &lt;h2&gt;I am Error&lt;/h2&gt; &lt;/div&gt; );&#125; 특징2. JavaScript ExpressionJSX안에서 javascript를 표현할 때는 그냥 { } 로 wrapping하면 된다. 아래의 예시를 보자. Example123456789101112131415161718import React from 'react';export default class App extends React.Component &#123; member = \"안녕하세요. 멤버 변수입니다.\"; render() &#123; let local =\"안녕하세요. 지역 변수입니다.\"; return ( &lt;div&gt; &lt;h1&gt;Hello World!!!&lt;/h1&gt; &lt;h2&gt;&#123; local &#125;&lt;/h2&gt; &lt;h2&gt;&#123; new Date().toString() &#125;&lt;/h2&gt; &lt;h2&gt;&#123; this.member &#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Example 실행결과 (줄 11) : { local } 부분에 7번 줄에서 정의했던 local지역 변수 값이 출력된다. (줄 12) : new Date().toString()표현식의 값, 즉 현재 시각이 출력된다. (줄 13) : 멤버 변수를 출력할 때는 반드시 this를 붙여주어야 한다. { this.member }부분에 4번 줄에서 정의했던 member멤버 변수 값이 출력된다. 특징3. Inline StyleJSX안에서 style을 설정할 때는 string형식을 사용하지 않고 key가 camelCase인 객체가 사용된다. (ex. background-color (x), backgroundColor (o)) 아래의 예제를 보자. Example12345678910render() &#123; let myStyle = &#123; color: 'yellow', backgroundColor: 'black' &#125;; return ( &lt;div style = &#123; myStyle &#125;&gt;Hello world!!&lt;/div&gt; );&#125; 특징4. commentsjsx안에서 주석을 작성할 때는 {/* ...*/} 형식으로 작성해야 한다. 주의할 점은 이 역시 container element안에 주석이 작성되어야 한다는 것이다. 아래의 예시를 보자. 1234567render() &#123; return ( &lt;div&gt; Hello world!! &#123;/*this is comment*/&#125; &lt;/div&gt; );&#125;","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"React.js","slug":"FrontEnd/React-js","permalink":"https://jess2.github.io/categories/FrontEnd/React-js/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"React.js","slug":"React-js","permalink":"https://jess2.github.io/tags/React-js/"}]},{"title":"[React] 간단한 프로젝트 구현해보기","slug":"React/React-간단한-프로젝트-구현해보기","date":"2018-05-30T12:35:19.000Z","updated":"2018-05-30T13:59:00.000Z","comments":true,"path":"2018/05/30/React/React-간단한-프로젝트-구현해보기/","link":"","permalink":"https://jess2.github.io/2018/05/30/React/React-간단한-프로젝트-구현해보기/","excerpt":"","text":"간단한 리액트 프로젝트 구현해보기이전 포스트에서 프로젝트를 생성하고 실행해봤다. 이제 직접 코드를 작성해보기 전에 프로젝트 내 src폴더 안에 있는 여러 파일들을 모두 삭제하자. 1. index.js 생성12345import React from 'react';import ReactDOM from 'react-dom';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); (줄 1~2) : react, react-dom 패키지를 불러오라는 설정이다. 번들링된 결과 파일에 이 패키지들의 소스코드도 포함되게 된다. (줄 3) : App.js 파일을 불러오라는 설정이다. 번들링된 결과 파일에 App.js파일의 소스 코드도 포함되게 된다. (줄 5) : ReactDOM이 render메소드를 이용하여 우리가 만든 컴포넌트를 렌더링한다. ReactDOM은 실제 페이지에 JSX형태의 코드를 렌더링할 때 사용되며 이 메소드의 첫 번째 인수는 우리가 렌더링할 JSX형태의 코드이다. 우리는 App컴포넌트를 렌더링할 거니까 첫 번째 인수에 &lt;App/&gt;을 적어준다. 이 메소드의 두 번째 인수는 이 컴포넌트를 렌더링할 element이다. 우리는 root element에 렌더링할 거니까 document.getElementById(&#39;root&#39;)를 적어준다. 그러면 index.html 파일에서 &lt;div id=&quot;root&quot;&gt;태그 내부에 &lt;App /&gt;확장 태그가 출력된다. &lt;App /&gt;는 html확장 태그이며, react.createElement(&quot;App&quot;, null)자바스크립트 코드로 변환된다. 이 태그는 App.js파일에 구현되어 있으며 App확장 태그에 해당하는 VirtualDOM자바스크립트 객체가 생성되고, 이 VirtualDOM객체가 &lt;div id=&quot;root&quot;&gt;태그 내부에 출력된다. 2. App.js 생성1234567891011import React from 'react';class App extends React.Component &#123; render() &#123; return ( &lt;div&gt;Hello World!!!&lt;/div&gt; ); &#125;&#125;export default App; (줄 1) : react패키지를 불러오라는 설정이다. 번들링된 결과 파일에 이 패키지들의 소스코드도 포함되게 된다. (줄 3~9) : React.Component클래스를 상속하여 App클래스를 구현한다. (줄 4~8) : render메소드는 &lt;div&gt;Hello World!!!&lt;/div&gt; 표현식의 값을 리턴한다. 이 표현식은 .jsx확장 문법으로 구현한 표현식이며 프로젝트를 빌드할 때 순수한 자바스크립트 코드로 변환된다. (줄 11) : App.js파일을 import한 곳에서 App클래스를 사용할 수 있다는 뜻이다. export로 지정되지 않을 경우에는 다른 곳에서 사용하지 못하며 이 파일 내부에서만 사용할 수 있다(private). 또한 이렇게 export default App;라고 별도로 써주지 않고 애초에 class를 작성할 때 아래와 같이 작성해줘도 된다.123export default class App extends React.Component &#123; ...&#125; 3. 실행1npm start","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"React.js","slug":"FrontEnd/React-js","permalink":"https://jess2.github.io/categories/FrontEnd/React-js/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"React.js","slug":"React-js","permalink":"https://jess2.github.io/tags/React-js/"}]},{"title":"[자료구조] 트리(Tree)","slug":"DataStructure/자료구조-트리-Tree","date":"2018-05-30T11:31:28.000Z","updated":"2018-06-06T13:39:46.000Z","comments":true,"path":"2018/05/30/DataStructure/자료구조-트리-Tree/","link":"","permalink":"https://jess2.github.io/2018/05/30/DataStructure/자료구조-트리-Tree/","excerpt":"","text":"트리(Tree)리스트와 스택, 큐는 자료들의 선의 형태로 나열되어 있는 구조를 가진 선형 자료구조였다. 자료들이 나열도니 구조가 선형이 아닌 자료구조를 비선형 자료구조라고 하는데, 트리(Tree)는 비선형 자료구조 중에서 자료들 간에 계층관계를 가진 계층형 자료구조이다. 트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 Graph의 특수한 형태이다. 가족의 계보(족보), 연산 수식, 회사 조직 구조도, 히프(Heap) 등을 표현하기에 적합하다. 트리 관련 용어 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것 근 노드(Root Node) : 트리의 맨 위에 있는 노드 디그리(Degree, 차수) : 각 노드에서 아래로 뻗어나온 가지의 수 단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드, Degree가 0인 노드 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드 조상 노드(Ancestors Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들 자식 노드(Child Node) : 어떤 노드에 연결된 다음 레벨의 노드들 부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들 형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들 Level : 근 노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L+1 깊이(Depth, Height) : Tree에서 노드가 가질 수 있는 최대의 레벨 숲(Forest) : 여러 개의 트리가 모여 있는 것 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수 이진 트리트리의 노드 구조를 일정하게 정의하면 트리의 연산이 단순화되어 쉬워진다. 그래서 모든 노드의 차수를 2 이하로 정하여 전체 트리의 차수가 2 이하가 되도록 만든 것이 이진 트리(Binary Tree)다. 이진 트리는 왼쪽 자식 노드와 오른쪽 자식 노드 2개만을 가질 수 있다. 이진 트리에 있는 모든 노드는 왼쪽 자식 노드를 루트로 하는 왼쪽 서브 트리와 오른쪽 자식 노드를 루트로 하는 오른쪽 서브 트리를 가진다. 그리고 이진 트리의 서브 트리들 역시 모두 이진 트리여야 한다. 이진 트리의 종류로 포화 이진 트리, 완전 이진 트리, 편향 이진 트리가 있다. 포화 이진 트리(Full Binary Tree) 포화 이진 트리는 모든 레벨에 노드가 꽉 차서 포화 상태인 이진 트리를 의미한다. 즉 포화 이진 트리는 높이가 h일 때 2h+1-1개의 최대 노드 수를 갖는 이진 트리다. 포화 이진 트리의 노드는 위치에 따라 일정한 노드 번호를 붙일 수 있다. 루트 노드를 1번으로 하고, 레벨 별로 왼쪽에서 오른쪽으로 차례로 2h+1-1까지 번호를 붙일 수 있다. 완전 이진 트리(Complete Binary Tree) 완전 이진 트리는 높이가 h이고 노드 수가 n개일 때, 노드의 위치가 포화 이진 트리의 노드 1번부터 n번까지의 위치와 완전히 일치하는 이진 트리다. 따라서 이진 트리에서는 n+1번부터 2h+1-1번까지의 노드는 공백 노드가 된다. 편향 이진 트리(Skewed Binary Tree) 이진 트리 중에서 최소 개수의 노드를 가지면서 왼쪽이나 오른쪽 서브 트리만 가지고 있는 트리를 편향 이진트리라고 한다.","categories":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/categories/CS/"},{"name":"DataStructure","slug":"CS/DataStructure","permalink":"https://jess2.github.io/categories/CS/DataStructure/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/tags/CS/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://jess2.github.io/tags/DataStructure/"}]},{"title":"[자료구조] 큐(Queue)","slug":"DataStructure/자료구조-큐-Queue","date":"2018-05-30T10:48:05.000Z","updated":"2018-06-06T13:39:46.000Z","comments":true,"path":"2018/05/30/DataStructure/자료구조-큐-Queue/","link":"","permalink":"https://jess2.github.io/2018/05/30/DataStructure/자료구조-큐-Queue/","excerpt":"","text":"큐(Queue)1. 큐의 개념 한쪽 끝에서는 삽입 작업만, 또 다른 한쪽 끝에서는 삭제 작업만! 큐(Queue)는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트이지만, 스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어져서, 삽입된 순서대로 삭제되는 선입선출(FIFO, First In Frist Out)의 구조로 운영된다. 2. 큐 - 자료의 삽입과 삭제 큐는 한쪽 끝은 front로 정하여 삭제 연산만 수행하도록 하고, 다른 쪽 끝은 rear로 정하여 삽입 연산만 수행하도록 한다. 따라서 가장 먼저 들어온 프런트 원소가 가장 먼저 삭제되므로 선입선출 구조가 된다. 3. 자료의 삽입1234567enQueue(Q, item) if(isFull(Q)) then Queue_Full(); else &#123; rear &lt;- rear + 1; Q[rear] &lt;- item; &#125;end enQueue() 포화 상태가 아닌 큐에 원소를 삽입하려면 배열에 저장되어 있는 마지막 원소의 다음 자리에 삽입을 해야 하므로, 마지막 원소의 인덱스를 저장한 rear의 값을 하나 증가시켜 삽입할 자리를 준비하고, 그 인덱스에 해당하는 배열 원소 Q[rear]에 item을 저장한다. 4. 자료의 삭제1234567deQueue(Q) if(isEmpty(Q)) then Queue_Empty(); else &#123; front &lt;- front + 1; return Q[front]; &#125;end deQueue() 공백 상태가 아닌 큐에서 원소의 삭제는 언제나 큐에 저장된 원소 중에서 가장 앞에 있는 원소, 즉 가장 먼저 큐에 들어와 있는 원소를 가장 먼저 삭제해야 한다. 그러기 위해서 front의 위치를 한 자리 뒤로 조정하여 큐에 남아있는 첫 번째 원소의 위치로 이동하여 삭제할 자리를 준비하고, 그 자리의 원소를 삭제하여 반환한다. 1234delete(Q) if(isEmpty(Q)) then Queue_Empty(); else front &lt;- front + 1;end delete(); delete()연산은 front의 원소를 삭제하는 연산이고 deQueue()연산은 front의 원소를 삭제하고 삭제한 원소를 반환하는 연산이다.","categories":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/categories/CS/"},{"name":"DataStructure","slug":"CS/DataStructure","permalink":"https://jess2.github.io/categories/CS/DataStructure/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/tags/CS/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://jess2.github.io/tags/DataStructure/"}]},{"title":"[자료구조] 스택(Stack)","slug":"DataStructure/자료구조-스택-Stack","date":"2018-05-29T13:19:37.000Z","updated":"2018-06-06T13:39:46.000Z","comments":true,"path":"2018/05/29/DataStructure/자료구조-스택-Stack/","link":"","permalink":"https://jess2.github.io/2018/05/29/DataStructure/자료구조-스택-Stack/","excerpt":"","text":"스택(Stack)1. 스택의 개념 자료의 삽입과 삭제가 한쪽 끝에서만! 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다. 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO; Last In First Out) 방식으로 자료를 처리한다. TOP : Stack으로 할당된 기억 공간에 가장 마지막으로 삽입된 자료가 기억된 위치를 가리키는 요소. 스택 포인터(SP, Stack Pointer)라고도 한다. Bottom : 스택의 가장 밑바닥이다. 2. 스택 - 자료의 삽입(Push)과 삭제(Pop) 3. 자료의 삽입(Push)12345Top = Top + 1If Top &gt; M Then OverflowElse X(Top) &lt;- Item 코드 설명 : 스택 포인터(Top)를 1 증가시킨다. 스택 포인터가 스택의 크기보다 크면 Overflow이고 그렇지 않으면 Item이 가지고 있는 값을 스택의 Top위치에 삽입한다. M : 스택의 크기 Top : 스택 포인터 X : 스택의 이름 Overflow : 스택으로 할당받은 메모리 부분의 마지막 주소가 M번지라고 할 때, Top Pointer의 값이 M보다 커지면 스택의 모든 기억장소가 꽉 채워져 있는 상태이므로 더 이상 자료를 삽입할 수 없어 Overflow를 발생시킨다. 4. 자료의 삭제(Pop)12345If Top = 0 Then UnderflowElse Item &lt;- X(Top) Top = Top - 1 코드 설명 : 스택 포인터가 0이면 스택의 바닥이므로 더 이상 삭제할 자료가 없으므로 Underflow를 처리한다. 그렇지 않으면 Top 위치에 있는 값을 Item으로 옮기고 스택 포인터를 1 감소시킨다. Stack에 기억되어 있는 자료를 삭제시킬 때는 제일 먼저 삭제할 자료가 있는지 없는지부터 확인해야 한다. Underflow : Top Pointer가 주소 0을 가지고 있다면 스택에는 삭제할 자료가 없으므로 Underflow를 발생시킨다. 5. Stack의 응용 분야 부 프로그램 호출 시 복귀주소를 저장할 때 함수 호출의 순서 제어 인터럽트가 발생하여 복귀주소를 저장할 때 후위 표기법(Postfix Notation)으로 표현된 수식을 연산할 때 0 주소지정방식 명령어의 자료 저장소 재귀(Recursive) 프로그램의 순서 제어 컴파일러를 이용한 언어 번역 시","categories":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/categories/CS/"},{"name":"DataStructure","slug":"CS/DataStructure","permalink":"https://jess2.github.io/categories/CS/DataStructure/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/tags/CS/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://jess2.github.io/tags/DataStructure/"}]},{"title":"[자료구조] 연결 리스트(Linked List)","slug":"DataStructure/자료구조-Linked-List","date":"2018-05-29T13:11:21.000Z","updated":"2018-06-06T13:39:46.000Z","comments":true,"path":"2018/05/29/DataStructure/자료구조-Linked-List/","link":"","permalink":"https://jess2.github.io/2018/05/29/DataStructure/자료구조-Linked-List/","excerpt":"","text":"연결 리스트(Linked List)Linked List란, 원소 간의 연결(link)을 이용해서 리스트를 구현한 것이다. 이전 포스트에서 설명한 Array List는 논리적인 순서와 물리적인 순서가 같기 때문에 원소의 위치를 찾아 접근하기 쉽다는 장점이 있지만, 삽입이나 삭제 후에 연속적인 물리 주소를 유지하기 위해서 원소들을 이동시키는 추가적인 작업과 시간이 필요하다. 하지만 연결 리스트는 리스트를 연결 자료구조 방식으로 표현한 구조로서, 원소들끼리 연결되어 있기 때문에 삽입이나 삭제를 할 때 연결만 달리 해주면 된다. 따라서 원소들을 이동시키는 추가적인 작업이 필요하지 않다. 노드연결 자료구조 방식에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 하기 때문에 &lt;원소, 주소&gt;의 단위로 저장해야 한다. 이러한 단위 구조를 노드(node)라고 한다. 각각의 노드가 다음 노드의 주소를 알고 있기 때문에 하나의 연결된 값의 모임을 만들 수 있는 것이다. 연결 리스트 삽입1) 리스트의 맨 앞에 노드 삽입 ① new &lt;- getNode() : 삽입할 노드를 자유 공간 리스트에서 할당받는다. ② new.data &lt;- x : 새 노드의 데이터 필드에 x를 저장한다. ③ new.link &lt;- L : 리스트 L의 첫 번째 노드에 대한 참조값을 삽입할 새 노드 new의 링크 필드에 저장함으로써 새 노드 new를 리스트 L의 첫 번째 노드와 연결한다. ④ L &lt;- new : 참조변수 L에 새 노드에 대한 참조값700을 저장하여 L이 새 노드 new를 첫 번째 노드로 가리키도록 지정한다. 123456insertFirstNode(L, x) new &lt;- getNode(); new.data &lt;- x; new.link &lt;- L; L &lt;- new;end insertFirstNode(); 2) 리스트의 중간에 노드 삽입 ① new.link &lt;- pre.link : 참조변수 pre는 삽입할 위치의 앞 노드를 가리킨다. 따라서 pre가 가리키는 노드의 다음 노드로 새 노드 new를 연결해야 하므로 노드 pre의 링크 필드값200을 노드 new의 링크 필드에 저장하여, 새 노드new가 노드 pre의 다음 노드를 가리키게 한다. ② pre.link &lt;- new : new의 주소700을 노드 pre의 링크 필드에 저장하여 pre가 가리키는 노드의 다음 노드로서 새 노드 new를 연결한다. 1234567891011insertMiddleNode(L, pre, x) new &lt;- getNode(); new.data &lt;- x; if (L = null) then &#123; L &lt;- new; new.link &lt;- null; &#125; else &#123; new.link &lt;- pre.link; pre.link &lt;- new; &#125;end insertMiddleNode() 3) 리스트의 마지막에 노드 삽입temp를 사용해서 가장 마지막 노드가 무엇인지 찾고, 가장 마지막 노드의 링크 필드값에 new의 주소700을 저장하여 가장 마지막 노드가 새 노드 new를 가리키게 한다. 12345678910111213insertLastNode(L, x) new &lt;- getNode(); new.data &lt;- x; new.link &lt;- null; if (L = null) then &#123; L &lt;- new; return; &#125; temp &lt;- L; while (temp.link != null) do temp &lt;- temp.link; temp.link &lt;- new;end insertLastNode() 연결 리스트 삭제삭제할 노드를 가리키는 참조변수 old와 삭제할 노드의 바로 앞의 노드를 가리키는 참조변수 pre를 이용하여 노드를 하나 삭제할 수 있다. ① old &lt;- pre.link : old는 삭제할 노드를 지시해야 하므로 노드 pre의 링크 필드값을 저장한다. ② pre.link &lt;- old.link : 삭제할 노드 old의 다음 노드를 노드 pre의 다음 노드로 연결한다. 123456789deleteNode(L, pre) if (L = null) then error; else &#123; old &lt;- pre.link; if (old = null) then return; pre.link &lt;- old.link; &#125; returnNode(old);end deleteNode() 추가자료구조 List 시각화 사이트를 참고하여 리스트에 대해 확실히 알아두자.","categories":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/categories/CS/"},{"name":"DataStructure","slug":"CS/DataStructure","permalink":"https://jess2.github.io/categories/CS/DataStructure/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/tags/CS/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://jess2.github.io/tags/DataStructure/"}]},{"title":"[자료구조] Array List","slug":"DataStructure/자료구조-Array-List","date":"2018-05-29T13:00:45.000Z","updated":"2018-06-06T13:39:46.000Z","comments":true,"path":"2018/05/29/DataStructure/자료구조-Array-List/","link":"","permalink":"https://jess2.github.io/2018/05/29/DataStructure/자료구조-Array-List/","excerpt":"","text":"Array ListArray List란, 동적 배열 중 하나이며 List를 만들 때 내부적으로 배열을 사용하는 것을 말한다. 장점 : 접근이 빠르다Array List는 내부적으로 배열을 이용하기 때문에 인덱스를 이용해서 접근한다. 이렇게 인덱스를 이용하여 접근하면 해당 값의 위치를 한 번에 찾을 수가 있기 때문에 연결 리스트보다 데이터의 접근이 빠르다. 단점 : 데이터의 추가와 삭제가 느리다데이터를 추가하려면 기존 데이터들을 뒤로 밀어야 원하는 자리에 넣을 수 있고, 데이터를 삭제한 후에는 그 데이터 뒤에 있던 데이터들을 다 앞쪽으로 당겨야 하기 때문에 연결 리스트보다 데이터의 추가와 삭제가 느리다. Example123456789101112131415161718192021222324//JavaArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(10); //데이터 추가list.add(11); //데이터 추가list.add(12); //데이터 추가System.out.println(list); //리스트 출력for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(i + \"번째 데이터: \" + list.get(i)); //리스트의 원소를 하나씩 반복문으로 출력&#125;list.remove(1); //1번 째 데이터 삭제System.out.println();System.out.println(\"1번째 데이터 삭제\");System.out.println();System.out.println(list); //리스트 출력for(int i=0; i&lt;list.size(); i++) &#123; System.out.println(i + \"번째 데이터: \" + list.get(i)); //리스트의 원소를 하나씩 반복문으로 출력&#125; Example 실행결과[10, 11, 12]0번째 데이터: 101번째 데이터: 112번째 데이터: 12 1번째 데이터 삭제 [10, 12]0번째 데이터: 101번째 데이터: 12 10, 11, 12 세 개의 데이터를 Array List에 추가한 후 1번 째 데이터인 11을 삭제했다. 이렇게 중간에 있는 데이터를 삭제하면 해당 데이터 뒤에 있던 데이터들이 앞쪽으로 당겨지기 때문에 1번 째 데이터는 12가 된다.","categories":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/categories/CS/"},{"name":"DataStructure","slug":"CS/DataStructure","permalink":"https://jess2.github.io/categories/CS/DataStructure/"}],"tags":[{"name":"CS","slug":"CS","permalink":"https://jess2.github.io/tags/CS/"},{"name":"DataStructure","slug":"DataStructure","permalink":"https://jess2.github.io/tags/DataStructure/"}]},{"title":"[React] 프로젝트 생성 및 실행","slug":"React/React-프로젝트-생성-및-실행","date":"2018-05-28T11:04:45.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/28/React/React-프로젝트-생성-및-실행/","link":"","permalink":"https://jess2.github.io/2018/05/28/React/React-프로젝트-생성-및-실행/","excerpt":"","text":"리액트 프로젝트 생성 및 실행 방법프로젝트 생성프로젝트 생성 명령 설치하기1npm install -g create-react-app 위 명령으로 리액트 프로젝트를 생성하는 create-react-app명령을 설치했다. -g옵션이 주어졌기 때문에 시스템 공통 폴더에 설치된다. 따라서 프로젝트를 새로 생성할 때마다 위 명령을 반복할 필요가 없다. 프로젝트 생성하기1create-react-app [프로젝트이름] create-react-app명령을 실행하여 프로젝트를 생성할 수 있다. 프로젝트 이름으로 영어 대문자는 사용이 불가능하다. 프로젝트 실행생성한 프로젝트 폴더에 들어가기1cd [프로젝트이름] 프로젝트 실행하기1npm start 해당 프로젝트 폴더에서 npm start명령을 실행하면 node.js에서 해당 프로젝트가 실행된다. 프로젝트 실행 결과 npm start명령을 입력한 후 잠시 기다리면 위와 같이 웹브라우저 창이 뜬다. 실행 과정 웹브라우저가 http://localhost:3000/주소의 서버에 http request를 전송 node.js 서버가 그 전송을 받아서 우리가 생성한 프로젝트를 실행 우리가 생성한 프로젝트의 실행결과가 웹브라우저로 전송 웹브라우저가 창에 우리가 생성한 프로젝트의 실행결과가 출력","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"React.js","slug":"FrontEnd/React-js","permalink":"https://jess2.github.io/categories/FrontEnd/React-js/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"React.js","slug":"React-js","permalink":"https://jess2.github.io/tags/React-js/"}]},{"title":"[React] 배경지식","slug":"React/React-배경지식","date":"2018-05-25T13:13:43.000Z","updated":"2018-05-30T13:34:40.000Z","comments":true,"path":"2018/05/25/React/React-배경지식/","link":"","permalink":"https://jess2.github.io/2018/05/25/React/React-배경지식/","excerpt":"","text":"React.js 배경지식1. 번들링(Bundling)웹페이지에 포함된 js, css 파일들이 많다. 그런데 웹브라우저가 웹페이지를 표시할 때, 웹페이지에 포함된 js, css 파일들도 서버에서 다운로드 해야한다. 서버에서 여러 파일들을 다운로드 할 때, 한 번에 파일 하나씩 다운로드 하는 것 보다 파일들을 묶어서 한 번에 다운로드 하는 것이 효율적이다. 웹페이지에 포함된 js, css 파일들을 웹브라우저가 한 번에 다운로드 할 수 있도록 묶어주는 기능을 번들링(Bundling)이라고 한다. 2. JSX 문법html 태그를 생성하는 자바스크립트 소스코드를 간결하게 입력할 수 있도록 자바스크립트 문법이 확장된 것을 jsx 문법이라고 한다. jsx 문법으로 구현한 표현식에는 반드시 루트 태그가 한 개 있어야 한다. 루트 태그 없이 태그를 여러 개 나열하면 에러가 발생한다. 아래의 예제를 보면 img태그와 h3태그를 div태그로 감쌌다. JSX 예제1234var profile = &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;h3&gt;&#123;[uuser.firstName, user.lastName].join(' ')&#125;&lt;/h3&gt;&lt;/div&gt;; 위 JSX 예제를 JavaScript 소스코드로 변환한 결과1234var profile = React.createElement(\"div\", null, React.createElement(\"img\", &#123; src: \"avatar.png\", className: \"profile\"&#125;), React.createElement(\"h3\", null, [user.firstName, user.lastName].join(' '))) 원래 아래의 형태로 구현해야 하지만 소스코드가 너무 지저분하니까 간단한 JSX 형태로 구현한다. 프로젝트를 빌드할 때, 빌드 도구가 JSX 형태의 소스코드를 JavaScript 소스코드로 자동 변환해준다. 확장자JSX 문법을 포함하는 자바스크립트 파일의 확장자가 옛날에는 .jsx였지만 최근에는 그냥 .js이다. 3. DOM (Document Object Model)DOM 객체웹 브라우저 내부에 구현된 html 태그 객체를 DOM 객체라고 한다. 웹브라우저가 웹페이지의 내용을 화면에 그릴 때, 그 웹페이지의 내용에 해당하는 DOM 객체들이 웹브라우저 내부에 생성된다. 웹브라우저 내부의 DOM 객체들을 수정하면 화면에 그려진 웹페이지 내용도 수정된다. VirtualDOM 객체자바스크립트 코드에 의해서 생성된 html 태그 객체이다. 이 객체는 웹브라우저 내부의 DOM 객체와 다르다. jsx 문법에 의해 생성되는 html 태그 객체는 VirtualDOM 객체이다. React and the Virtual DOM 설명 영상 4. let 키워드자바스크립트 지역 변수를 선언하기 위한 키워드가 var였다. 그러나 ES6 문법에서는 var대신 let키워드를 사용하는 것이 바람직하다. var 지역변수 선언 방식의 문제점123var a = 3;var a = 4;document.write(a); //출력 결과 &gt; 4 지역 변수 a를 재선언해도 에러가 발생하지 않는다. 이름이 같은 지역변수를 실수로 여러 번 생성할 수 있는 문제가 있다. let 지역변수123let a = 3;let a = 4; //에러 발생document.write(a); Duplicate declaration &quot;a&quot;에러 발생 =&gt; 실수를 발견할 수 있다. 이 두 키워드에 대해 자세히 알아보려면 여기를 클릭하자. 5. 확장 태그1234567class Main extends React.Component &#123; //확장 태그 클래스(React Component) render() &#123; //render 메소드 return ( //리턴값은 jsx 확장 문법으로 구현 &lt;div&gt;Hello World!&lt;/div&gt; ); &#125;&#125; 확장 태그 구현React.Component 클래스를 상속하여 확장 태그 클래스를 구현한다. 확장 태그 클래스를 React Component라고 부른다. render 메소드확장 태그 클래스에서 render메소드를 구현해야 한다. render메소드에서 확장 태그의 구체적인 형태를 구현해야 하는데 확장 태그의 내용은 html태그나 다른 확장 태그들로 구성되어야 한다. render 메소드의 리턴값확장 태그의 내용에 해당하는 태그 객체를 생성해서 리턴해야 한다. jsx확장 문법으로 구현한다. 확장 태그가 웹브라우저 창에 그려질 때(rendering)확장 태그의 render메소드가 리턴하는 태그 객체로 치환되어서 그려진다. 치환된 태그에도 확장 태그가 포함되어 있다면 그 확장 태그도 치환된다. (render메소드 재귀 호출) 6. 프레임워크 vs 라이브러리1) 프레임워크 필요한 기능이 이미 대부분 만들어져 있고, 틀(frame) 안에 우리가 내용을 채워 넣어 완성시키는 것 틀을 벗어나기 힘든 것이 단점 보통 단 한 가지의 프레임워크를 사용함 가끔 다른 프레임워크나 라이브러리와 함께 이용할 때, 충돌하는 경우도 있어서 따로 고쳐줘야 함 우리가 아예 사용하지 않을 기능도 구현되어 있기 때문에 상황에 따라서 조금 무겁게 느껴지기도 함 2) 라이브러리 필요한 부분에만 가져다 쓰면 되는 개념 다른 라이브러리와 충돌할 일이 없음 7. React.js는 프레임워크가 아닌 라이브러리React는 user interface를 만들기 위한 라이브러리다. ReactJS가 AngularJS를 대체할 수 있을까? NO!!! Angular는 프레임워크다. React와 Angular는 완전히 다른 것이기 때문에 사과와 오렌지를 비교하는 것과 같은 느낌.(참고. react-native : 모바일 네이티브 앱을 리액트로 만들 수 있게 해주는 프레임워크) 8. React의 장/단점장점 Virtual DOM을 사용 배우기 간단함 컴포넌트 단 하나만을 사용함 뛰어난 garbage collection, 메모리관리, 성능 서버 렌더링 &amp; 클라이언트 렌더링 둘 다 지원 매우 간편한 UI 수정 및 재사용 (UI를 컴포넌트화 하여 재사용함) 페이스북이 밀어줌 다른 프레임워크나 라이브러리와 혼용 가능 단점 VIEW ONLY : 리엑트는 보여지는 부분만 관리함 자바스크립트 배경지식이 부족하면 처음에 구현하는 것이 조금 힘들 수 있음 IE8 이하 버전은 지원 안함","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"React.js","slug":"FrontEnd/React-js","permalink":"https://jess2.github.io/categories/FrontEnd/React-js/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"React.js","slug":"React-js","permalink":"https://jess2.github.io/tags/React-js/"}]},{"title":"2018년 1회 정보처리기사 실기 합격후기","slug":"etc/2018년-1회-정보처리기사-실기-합격후기","date":"2018-05-25T11:48:26.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/25/etc/2018년-1회-정보처리기사-실기-합격후기/","link":"","permalink":"https://jess2.github.io/2018/05/25/etc/2018년-1회-정보처리기사-실기-합격후기/","excerpt":"","text":"2018년 1회 정보처리기사 실기 합격후기 시험 준비 전공부를 시작하기 전, 책을 고르는 것에는 큰 어려움이 없었다. 정보처리기사 필기 시험도 시나공 책으로 붙었으니 실기 시험도 시나공으로 공부하면 되겠지라는 생각으로 별 고민 없이 바로 시나공 실기 책을 구입했다. 평소에 아이패드로 책 보는 것을 좋아해서 스캔 후 아이패드에 넣어놨다. 그런데 이렇게 e-book으로 보는 것의 단점이 책의 분량이 도대체 얼마나 되는지 실제 책보다 가늠이 잘 안된다는 거다. 그래서 이 때는 공부해야할 양이 정말 방대하다는 것을 알지 못했다. 그리고 일단 목차만 봤을 때는 1과목은 알고리즘이고 2과목은 데이터베이스인데, 이 두 과목은 이미 대학교에서 배운 과목이고 시험에서의 배점이 가장 높기 때문에 합격하는 것은 별로 어렵지 않아보였다. 그러고나서 시험에 대한 정보를 수집하기 위해 포털사이트에 ‘정보처리기사 실기’라고 검색해봤다. 뭐? 합격률이 11%??? 일단 직전 시험인 2017년 3회 실기 합격률이 11%, 그리고 2017년 2회 실기 합격률은 23%라고 해서 많이 놀랐다. 2017년부터 주관식으로 바뀌어서 어려워졌다고 한다. 그리고 ‘정보처리기사 실기 오리엔테이션’ 영상이 있길래 봤는데 실기 시험은 준비기간으로 두 달은 잡아야 한다는 거다. 필기 시험 준비 기간은 2주면 충분했는데 두 달이라니(…) 시험 준비 기간 : 3주그렇게 멘붕이 온 상태로 책을 폈는데 정말 공부를 하면 할 수록 “분량이 엄청 방대하다”라는 걸 느꼈다. 전공자라고 해도 절대 쉽게 생각할 게 아니다. 나는 하루에 꽤 많은 시간씩 투자해서 3주가 걸렸지만, 분량이 꽤 많은데다가 주관식이기 때문에 하루에 많은 시간을 투자하지 못한다면 준비기간으로 한 달 이상은 잡아야할 것 같다. 그리고 시나공 책에 시험에 자주 출제되는 순서로 A, B, C, D 단계가 있는데 필기시험과 실기시험 모두 A와 B 단계만 봤다. C, D는 아예 안봤는데 준비 기간이 넉넉하지 않다면 A와 B 단계만 봐도 충분한 것 같다. 1과목. 실무 알고리즘 응용시나공은 총 세 권으로 분권이 되어있는데 1분권이 전부 1과목으로만 되어 있었다. 그리고 책에 생각보다 이해하기 어려운 순서도 문제도 많이 있어서 마음이 더 조급해졌다. 시험에서 알고리즘이 어렵게 나오면 진짜 바로 불합격이겠구나 싶었다. 어려운 문제도 차근 차근 생각하면서 디버깅해보면 대부분 풀리긴 풀리는데 확실히 연습이 많이 필요해보였다. 그래서 어려운 문제들을 직접 디버깅 해보는 연습을 많이 했다. 그런데 시험 때는 알고리즘 문제가 생각보다 너무 쉽게 나왔다. 고민을 깊게 할 필요가 없는 문제가 나와서 당황스럽긴 했는데 혹시나 너무 쉬워서 실수할까봐 몇 번이나 다시 디버깅해보고 체크했다. 시험에서 실수를 하지 않는 것이 제일 중요하다. 2과목. 데이터베이스 실무 응용2과목은 필기시험 때 공부했던 범위랑 상당히 많이 겹치기 때문에 1과목에 비해 수월하게 진도를 뺄 수 있었다. 분량도 1과목에 비해 절반도 안되는 것 같다. SQL문 짜는 게 배점이 높다고 해서 SQL 짜는 것 위주로 연습을 했고 개념도 꼼꼼히 외우려고 했다. 특히 정규화 개념 확실히 알아두려고 했다. 그런데 위에 언급했다시피 C, D단계는 안보고 A, B단계만 봤는데 그렇게 보니까 2과목은 특히 분량이 많이 줄었다. 시험에서는 그렇게 어렵게 나오진 않았고 책에 있는 내용만 잘 숙지했다면 충분히 어렵지 않게 풀 수 있는 수준이었다. 그리고 혹시 실수한 것이 있을까봐 여러번 다시 체크했다. 3과목. 업무 프로세스 실무 응용목차에서 페이지 수로 봤을 때 3과목은 2과목 분량의 절반이었다. 1과목 분량에 멘붕 당했던 한 사람으로서 3과목 분량에 너무 감사했다. 그런데(…) 3과목은 페이지 수는 적지만 외워야할 내용은 제일 많았다. 정말 아무리 읽어도 무슨 소린지도 모르겠고 다 말장난처럼 보였다. VBM, ABM, ERM, SCM, PLM……..다 나열할 수 없을만큼 양이 정말 방대한데, 영어 약자들이 정말 미워보였다. 이걸 다 어떻게 외우지 싶고.. 게다가 주관식이니까 개념이 나왔을 때 그에 맞는 답을 직접 써야한다는 것이 굉장히 부담스러웠다. 그리고 각각 개념들을 한글로 설명할 줄도 알아야하고 장점이나 특징들도 알고 있어야 하니 계속 반복해서 보는 수 밖에 없었다. 그래도 계속 반복하다보니까 외우는 데 요령이 생겼다. 마지막에는 단어들만 써 놓은 뒤에 단어만 보고 그 개념을 말할 수 있도록 공부했고, 개념만 요약해서 써 놓은 뒤에 그 개념에 맞는 단어를 말할 수 있도록 공부했다. 시험에서는 책에 나와있는 예제와 비슷한 느낌으로 출제가 되었다. 4과목. IT 신기술 동향 및 시스템 관리솔직히 공부 안했다. 음.. 마지막에 시험장 들어가기 직전에 처음으로 한 번 보긴 했는데 그 내용들이 시험에 나오진 않았다. 신기술 동향 단어가 정말 너무 너무 많고 어떤 내용이 나올 지 모르기 때문에 솔직히 공부 기간이 얼마 안남은 시점에서 4과목을 새롭게 보느니 1,2,3과목 복습을 하는 게 나을 것 같아서 복습을 했다. 5과목. 전산영어책 목차에는 분명히 전산영어가 적혀있는데 책 어딜 살펴봐도 전산영어에 대한 개념은 없었다. 전산영어가 어떤 개념이 따로 있는 줄 알았는데 그게 아니였고 그 동안 배웠던 내용(필기 시험 개념 포함)을 영어 지문으로 문제를 내는 건데, 그렇기 때문에 뭐 5과목도 따로 공부하진 않았다. 시험에서는 아는 한에서 풀었고 크게 어렵게 나오진 않는 것 같다. 기출기출 문제를 좀 많이 풀어봤어야 했는데 그러질 못했다. 자꾸 3과목 개념을 잊을 것만 같아서 자꾸 복습했고 2과목 정규화도 한번 더 확실하게 되새기고 SQL문 짜는 것도 다시 보는 등 복습에 집중을 했다. 책의 각 챕터 마지막 부분에 있는 문제들은 다 풀었지만 정식 기출문제는 2회 정도 풀었다. 마무리떨어지면 다시 공부해야 한다는 생각에 필사적인 3주를 보냈는데 합격을 하니 뿌듯하다. 합격률이 낮든 높든 꼭 합격하겠다는 생각으로 열심히 준비하면 충분히 합격할 수 있는 시험이라고 생각한다.","categories":[{"name":"etc.","slug":"etc","permalink":"https://jess2.github.io/categories/etc/"}],"tags":[{"name":"exam","slug":"exam","permalink":"https://jess2.github.io/tags/exam/"}]},{"title":"[JS] this","slug":"JavaScript/JS-this","date":"2018-05-24T11:59:53.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/24/JavaScript/JS-this/","link":"","permalink":"https://jess2.github.io/2018/05/24/JavaScript/JS-this/","excerpt":"","text":"this자바스크립트에서의 this는 함수의 현재 실행 문맥이다. 함수 실행에서의 this함수 실행에서의 this는 전역 객체다. 전역 객체는 실행 환경에 따라 결정되는데, 웹 브라우저에서는 window가 전역 객체다. 아래의 예시를 보자. 12345678910function sum(a, b) &#123; document.write(this === window); // true this.myNumber = 20; return a + b;&#125; var obj = sum(15, 16); document.write(obj); // 31document.write(obj.myNumber); // undefineddocument.write(window.myNumber); // 20 7행에서 sum함수를 호출한 결과를 obj라는 변수에 넣었다. sum함수의 매개변수로 15와 16을 전달했고, 1행의 sum함수가 실행된다. 이 때, 7행에서 sum함수를 호출할 때의 this는 전역 객체인 window이므로 2행에서 this === window의 결과는 true이다. 그 후, 3행에서 window객체의 myNumber에 20을 저장한 뒤, 4행에서 15와 16을 더하여 반환한다. 그 반환 값은 7행의 obj에 저장되기 때문에, 8행의 결과는 31이다. 그리고 9행의 obj.myNumber은 정의한 적이 없기 때문에 undefined이며, 10행의 window.myNumber은 아까 3행에서 20으로 저장했기 때문에 20을 출력한다. 그렇다면 이번엔 다음 예제를 보자. 123456789function sum(a, b) &#123; document.write(this === window); // false this.myNumber = 20; return a + b;&#125;var obj = new sum(15, 16); document.write(obj); // [object Object]document.write(obj.myNumber); // 20document.write(window.myNumber); // undefined 이번엔 sum형 객체로 obj를 생성했다. 객체를 생성했을 때의 this는 그 객체 자신이 되기 때문에 2행에서의 this는 obj이다. 따라서 this === window의 값은 false이다. 3행에서 this.myNumber은 obj.myNumber을 의미하기 때문에 obj.myNumber에 20을 저장한다. 그리고 obj는 객체이기 때문에 7행에서 obj의 출력 결과는 [object Object]이다. 8행의 실행 결과는 아까 저장한대로 20이며, window.myNumber은 정의한 적이 없기 때문에 undefined이다. 엄격 모드 함수 실행에서의 this엄격 모드에서 함수 실행에서의 this는 undefined이다. 그리고, 엄격 모드는 현재 스코프 뿐만 아니라 내부 스코프에서도 적용된다. 123456789function sum(a, b) &#123; 'use strict'; // 엄격 모드 document.write(this === window); // false document.write(this === undefined); // true return a + b;&#125; var num = sum(2, 5);document.write(num); // 7 내부 함수에서의 this내부 함수의 문맥은 외부 함수의 문맥에 의존되는 게 아니라 오로지 실행 환경에 좌우된다. 아래의 예시를 보자. 12345678910111213141516var numbers = &#123; numA: 5, numB: 10, sum: function() &#123; document.write(this === numbers); // true function calc() &#123; document.write(this === numbers); // false document.write(this === window); // true return this.numA + this.numB; &#125; return calc(); &#125;&#125;; var result = numbers.sum();document.write(result); // NaN numbers.sum()은 객체 내에 있는 메소드를 실행하는 것이기 때문에 sum메소드 내의 문맥은 numbers객체다. 즉, 5행에서 외부 함수의 this는 numbers인 것이다. 하지만 calc함수는 sum함수 내부에 정의되었다. 이 때 this는 window이다. 또한 이 때 9행에서 this가 window이기 때문에 16행의 출력결과는 NaN이 되는 것이다. 이러한 문제를 해결하기 위해서 calc함수도 sum메소드와 동일한 문맥 상에 있어야 한다. 그래야 numA와 numB속성에 접근할 수 있기 때문이다. 이를 해결하려면 call이나 apply또는 bind를 사용하면 된다. 여기서는 call메소드를 사용하여 해결해보겠다. 12345678910111213141516var numbers = &#123; numA: 5, numB: 10, sum: function() &#123; document.write(this === numbers); // true function calc() &#123; document.write(this === numbers); // true document.write(this === window); // false return this.numA + this.numB; &#125; return calc.call(this); &#125;&#125;; var result = numbers.sum();document.write(result); // 15 11행의 this는 외부 함수인 sum메소드에 속하기 때문에 numbers이다. 따라서 calc.call(this)는 numbers객체에 calc라는 메소드를 등록해주는 셈이기 때문에, calc메소드의 this도 numbers가 된다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] Ajax와 XML / JSON","slug":"JavaScript/JS-ajax와-xml-json","date":"2018-05-24T11:05:27.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/24/JavaScript/JS-ajax와-xml-json/","link":"","permalink":"https://jess2.github.io/2018/05/24/JavaScript/JS-ajax와-xml-json/","excerpt":"","text":"Ajax와 XML / JSONAjax (Asynchronous JavaScript and XML)Ajax는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 보통 브라우저에서 웹페이지를 요청하면 서버와 통신하여 화면을 refresh하는데, Ajax를 이용하여, 서버로부터 웹 페이지가 반환될 때 화면 전체를 refresh하지 않고, 일부만을 갱신할 수 있게 해준다. 이와 같은 효과로 인해, 페이지 전체를 로드하여 렌더링할 필요가 없어지며, 갱신이 필요한 일부만 로드하여 갱신하면 되므로 빠른 퍼포먼스와 부드러운 화면 표시 효과를 기대할 수 있다. 특히 jQuery라이브러리로 Ajax를 사용하면 자바스크립트로만 처리하는 것에 비해 간결해지고 크로스 브라우징 문제도 해결된다. Ajax는 비동기적으로 서버와 브라우저가 데이터를 주고 받는데, 이 때 사용하는 API가 XMLHttpRequest이다. 그렇다고 꼭 XML만을 사용해서 통신해야 하는 것은 아니다. 사실 XML보다는 JSON을 더 많이 사용한다. 데이터 전송 형식 - XML / JSON서버와 클라이언트 또는 애플리케이션에서 처리할 데이터를 주고받을 때 쓰는 자료 형식 중 대표적인 것으로는 XML과 JSON이 있다. XMLHTML과 같이 태그 구조의 형식으로 데이터를 표현한다. XML문법 특성상 데이터 이외에 열고 닫는 태그가 반드시 필요하기 때문에 구조가 복잡해지고 용량이 커지는 것이 단점이다. XML Example123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;books&gt; &lt;book&gt; &lt;title&gt;자바스크립트&lt;/title&gt; &lt;author&gt;Jessie&lt;/author&gt; &lt;price&gt;20000&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;알고리즘&lt;/title&gt; &lt;author&gt;cokk&lt;/author&gt; &lt;price&gt;15000&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title&gt;자료구조&lt;/title&gt; &lt;author&gt;ellie&lt;/author&gt; &lt;price&gt;18000&lt;/price&gt; &lt;/book&gt;&lt;/books&gt; $.ajax() 메소드서버에 지정한 형식의 자료를 요청하는 제이쿼리 범용 메소드이다. XML, JSON 등 다양한 타입의 자료를 요청할 수 있다. $.ajax() 메소드 형식12345678$.ajax(&#123; url: '가져올 파일명', dataType: '데이터 형식', success: function() &#123; //콜백 함수(가져온 파일에 대한 처리) ... &#125;&#125;); Example - ajax() 메소드로 xml 문서 불러오기12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; $(function()&#123; $.ajax(&#123; url: 'book.xml', dataType: 'xml', success: function(data)&#123; $(data).find('book').each(function()&#123; var title = $('title', this).text(); var author = $('author', this).text(); var price = $('price', this).text(); var txt = \"&lt;li&gt;\" + title + \", \" + author + \", \" + price + \"&lt;/li&gt;&lt;hr&gt;\"; $('body').append(txt); &#125;); &#125; &#125;); &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; (줄 10) : 불러올 파일의 경로를 지정. (줄 11) : 불러올 파일의 형식을 지정. xml형식의 파일을 불러온다. (줄 12) : 파일을 불러오는 데 성공하면 콜백 함수를 처리한다. 콜백 함수 내부에서는 xml데이터를 불러와서 항목별로 표시하기 위해 각각의 변수에 할당하는 작업을 했다. (줄 13) : $(data)는 $.ajax()메소드가 book.xml파일에서 불러온 데이터 객체다. find()메소드로 하위 book객체를 찾아서 작성된 book객체만큼 each()를 반복 수행한다. (줄 14) : this는 현재 book객체를 의미하고, title은 book객체 안의 title객체를 선택한다는 의미이다. 선택한 객체의 내용을 title변수에 대입한 것이며 나머지 author과 price도 같은 형태로 지정한다. JSONJSON(JavaScript Object Notation)은 자바스크립트 객체 데이터 형식으로, XML데이터 형식에 비해 구조 정의의 용이성과 가독성이 뛰어나서 AJAX의 표준으로 사용된다. JSON Example123456789&#123; \"student\": &#123; \"이름\": \"Jessie\", \"성별\": \"여\", \"주소\": \"경기도 용인시 수지구\", \"취미\": \"프로그래밍\", \"별명\": \"제씨\" &#125;&#125; $.getJSON() 메소드제이쿼리 getJSON()메소드는 ajax()메소드의 축약형으로, JSON데이터에 특화되어 있다. $.getJSON() 메소드 형식1$.getJSON(url, 콜백함수); Example - getJSON() 메소드로 JSON 문서 불러오기12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.3/jquery.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; $(function()&#123; //json 파일을 data로 가져옴 $.getJSON('book.json', function()&#123; //data 객체 지정 var books = data.book; //데이터 순회 $(books).each(function(i, obj)&#123; var title = obj.title; var author = obj.author; var price = obj.price; var txt = \"&lt;li&gt;\" + title + \", \" + author + \", \" + price + \"&lt;/li&gt;&lt;hr&gt;\"; $('body').append(txt); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; (줄 12) : data객체는 json()에서 불러온 데이터이다. data객체의 book객체를 지정해 변수 book에 대입한다. (줄 14) : each()메소드로 book객체에 포함된 내부 속성 값을 읽어와 출력한다. i는 book객체의 배열 index값이고, obj는 book객체를 의미한다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] bind","slug":"JavaScript/JS-bind","date":"2018-05-24T10:45:01.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/24/JavaScript/JS-bind/","link":"","permalink":"https://jess2.github.io/2018/05/24/JavaScript/JS-bind/","excerpt":"","text":"bindFunction객체에서 기본적으로 가지고 있는 메소드 중 call, apply, bind를 많이 사용하는데 이 세 가지의 차이점을 알아보자. 우선 call과 apply는 함수를 즉시 호출하고 컨텍스트를 수정할 때 사용된다.(call과 apply에 대해 자세히 알아보기) 그러나 bind는 해당 함수를 나중에 이벤트에서 유용한 특정 컨텍스트로 호출할 때 사용된다. 정리하면, call과 apply는 즉시 함수를 호출하지만 bind는 나중에 실행될 때 함수를 호출하기 위한 올바른 컨텍스트를 갖게되는 함수를 반환한다. bind를 사용하여 비동기 콜백 및 이벤트에서 컨텍스트를 유지 관리할 수 있고, 특정 함수에 대해 원본 함수와 동일한 본문을 갖는 바인딩된 함수를 만든다. 다음 예제를 보자. Example12345678910111213141516function Button(content) &#123; this.content = content;&#125;; Button.prototype.click = function() &#123; document.write(this.content + ' clicked');&#125;; var myButton = new Button('OK');myButton.click(); // OK clicked var looseClick = myButton.click;looseClick(); // undefined clicked var boundClick = myButton.click.bind(myButton);boundClick(); // OK clicked 9행에서 Button형 객체인 myButton를 만들었고, 인자 값은 OK이다. 이 때, 10행과 같이 myButton.click()을 실행하면, 프로토타입 체인에 의해서 OK clicked가 정상적으로 출력이 된다. 하지만 12행에서는 myButton.click을 looseClick에 담고, 13행에서 looseClick()을 실행했다. 그러나 이렇게 하면, 12행에서 이미 click 함수가 종료되었기 때문에 13행에서는 this.content를 찾을 수 없게 되어 undefined가 뜬다. bind 메소드는 이와 같은 문제를 해결해준다. bind 메소드는 특정 함수에 대해 원본 함수와 동일한 본문을 갖는 바인딩된 함수를 만들기 때문에, 16행에서 boundClick()을 실행하면 정상적으로 OK clicked가 출력이 된다. bind의 인자 추가 기능123456789var sum = function(a, b) &#123; return a + b;&#125;; var add1 = sum(10, 5);document.write(add1); // 15 var add2 = sum.bind(null, 5);document.write(add2(10)); // 15 5~6행은 일반적인 함수 호출방법이다. sum이라는 함수에 인자를 전달하여 return된 값을 add1에 저장하고, 출력한다. 그러나 8행을 보면, 첫 번째 인자로 null이 주어졌고, 이후에 9행에서 add2의 인자값으로 10이 주어졌다. 이렇게 bind를 사용하면 나중에 인자값을 추가할 수 있으며 이 인자는 원래 함수의 매개변수로 전달한다. 나중에 바인딩 된 함수에 전달하는 모든 추가 매개변수는 바인딩된 매개변수 다음에 전달된다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] call과 apply","slug":"JavaScript/JS-함수의-호출-방법-call과-apply","date":"2018-05-24T09:52:11.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/24/JavaScript/JS-함수의-호출-방법-call과-apply/","link":"","permalink":"https://jess2.github.io/2018/05/24/JavaScript/JS-함수의-호출-방법-call과-apply/","excerpt":"","text":"함수의 호출 방법 - call과 applycall과 apply에 대해 알아보기 전에 먼저 함수의 기본적인 호출 방법에 대해 알아보자. 12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125; document.write(sum(2, 3)); // 출력결과 &gt; 5 sum이라는 함수에 매개변수로 두 개의 값을 받고 있으므로 이 함수를 호출할 때, sum(2, 3)이런 식으로 호출했다. 함수의 리턴값은 5다. 이 외에도 JavaScript에서는 기본적인 함수 호출 방법 이외의 다른 방법들을 제공한다. 함수의 호출 방법인 call과 apply에 대해 알아보자. call과 apply아래의 call Example과 apply Example은 위의 기본적인 함수 호출과 동일한 결과를 가져온다. call Example12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125;document.write(sum.call(null, 2, 3)); apply Example12345function sum(arg1, arg2) &#123; return arg1 + arg2;&#125; document.write(sum.apply(null, [2, 3])); 기본적으로 Function 객체는 call과 apply메소드를 가지고 있는데, sum도 Function객체의 인스턴스이기 때문에, 객체 Function의 메소드인 call과 apply를 호출할 수 있다. call과 apply는 비슷하지만, 매개변수를 전달하는 방식이 다르다. 개발자가 편한 방식을 선택하면 되는데, arguments객체를 그대로 전달해도 되거나 매개변수로 전달할 데이터가 이미 배열 형태로 준비되어 있다면 apply가 나을 것이고, 그렇지 않다면 call이 나을 것이다. 전달할 매개변수가 없다면 두 메소드는 완전히 동일하다. 그런데 왜 굳이 call과 apply같은 방식을 사용하여 함수를 호출해야 하는가? call과 apply를 사용하여 함수를 호출하면 그 함수를 해당 객체의 메소드로 만들어 버린다. 아래의 예제를 보자. Example12345678910111213o1 = &#123;val1:1, val2:2, val3:3&#125;;o2 = &#123;v1:10, v2:50, v3:100, v4:25&#125;; function sum()&#123; var _sum = 0; for(name in this)&#123; _sum += this[name]; &#125; return _sum;&#125; alert(sum.apply(o1)); // 결과 : 6alert(sum.apply(o2)); // 결과 : 185 우선 12행의 sum.apply(o1)를 살펴보자. sum.apply(o1)는 함수 sum을 객체 o1의 메소드로 만들고, sum을 호출한다. 이렇게 되면, 함수 sum안에 있는 this는 객체 o1을 뜻하게 되는 것이다. 함수 sum안에서 반복문을 돌면서 객체 o1의 키값들 (val1, val2, val3)이 차례대로 name이라는 값으로 들어가게 되며, this[name]의 값은 해당 키값의 value들을 말한다. 그래서 차례대로 1, 2, 3이 더해져 6이라는 결과가 나온 것이다.13행도 12행과 마찬가지로 실행된다. 아래의 또 다른 예제를 보자. Example1234567891011121314window.color = \"red\";var obj = &#123; color : \"blue\"&#125;; function func() &#123; document.write(this.color);&#125;; func(); // 출력결과 &gt; redfunc.call(this); // 출력결과 &gt; redfunc.call(obj); // 출력결과 &gt; bluefunc.apply(this); // 출력결과 &gt; redfunc.apply(obj); // 출력결과 &gt; blue (줄 10) : 일반적인 함수 호출 방법으로 함수를 호출했다. 함수 내의 this는 window객체를 가리키기 때문에 red가 출력된다. (줄 11) : call을 사용하여 함수를 호출했고 인자로 this를 넘겼다. 여기서 this는 window객체를 가리키기 때문에 함수 func()는 window의 메소드가 되는 것이다. 따라서 func()내의 this는 window를 가리키기 때문에 red가 출력된다. (줄 12) : call을 사용하여 함수를 호출했고 인자로 obj객체를 넘겼다. 따라서 함수 func()는 obj객체의 메소드가 되기 때문에 func()내의 this는 obj를 가리키므로 blue가 출력된다. (줄 13, 14) : 각각 줄 11, 12와 같은 원리로 red와 blue가 출력된다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 프로토타입(Prototype)","slug":"JavaScript/JS-프로토타입-Prototype","date":"2018-05-23T13:35:55.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/23/JavaScript/JS-프로토타입-Prototype/","link":"","permalink":"https://jess2.github.io/2018/05/23/JavaScript/JS-프로토타입-Prototype/","excerpt":"","text":"프로토타입(Prototype)객체는 속성을 가질 수 있는데, prototype이라는 속성은 그 용도가 약속되어 있는 특수한 속성이다. prototype에 저장된 속성들은 생성자를 통해서 객체가 만들어질 때 그 객체에 연결된다. 자바스크립트의 모든 객체는 자신을 생성한 객체 원형에 대한 숨겨진 연결을 갖는다. 이 때, 자기 자신을 생성하기 위해 사용된 객체 원형을 프로토타입이라 한다. 자바스크립트의 모든 객체는 Object 객체의 프로토타입을 기반으로 확장되었기 때문에 이 연결의 끝은 Object 객체의 프로토타입 Object이다. 어떠한 객체가 만들어지기 위해 그 객체의 모태가 되는 것을 프로토타입이라고 한다. Example1234567891011function Ultra()&#123;&#125;Ultra.prototype.ultraProp = true; function Super()&#123;&#125;Super.prototype = new Ultra(); function Sub()&#123;&#125;Sub.prototype = new Super(); var o = new Sub();console.log(o.ultraProp); // 출력결과 &gt; true 생성자 Sub를 통해서 만들어진 객체 o가 Ultra의 속성인 ultraProp에 접근이 가능한 이유는 prototype 체인으로 Sub와 Ultra가 연결되어있기 때문이다. 내부적으로는 아래와 같은 일이 일어난다. 객체 o에서 ultraProp을 찾는다. 없다면 Sub.prototype.ultraProp을 찾는다. 없다면 Super.prototype.ultraProp을 찾는다. 없다면 Ultra.prototype.ultraProp을 찾는다. Example12345678910111213141516171819function Person(name) &#123; this.name = name;&#125;Person.prototype.name = null;Person.prototype.introduce = function() &#123; return 'My name is ' + this.name;&#125; function Programmer(name) &#123; this.name = name;&#125;Programmer.prototype = new Person(); //상속Programmer.prototype.coding = function() &#123; return \"hello world\";&#125; var p1 = new Programmer('jessie');document.write(p1.introduce() + \"&lt;br/&gt;\"); //출력결과 : My name is jessiedocument.write(p1.coding() + \"&lt;br/&gt;\"); //출력결과 : hello world Programmer는 Person을 상속받았기 때문에 introduce라는 속성을 갖고 있지 않아도, Person의 속성인 introduce에 접근이 가능하기 때문에 18행의 p1.introduce()가 정상적으로 호출되어 출력이 된다. 프로토타입으로 메소드 생성 -&gt; 공간 절약우리는 아래와 같은 방법으로 생성자 함수와 인스턴스 객체를 만들 수 있다. 12345678910function Character(name, job) &#123; this.name = name; this.job = job; this.move = function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`); &#125;&#125; var char1 = new Character('루이스', '기사');char1.move(); 위의 코드에서 Character는 생성자 함수이며, char1은 인스턴스 객체다. Character생성자 함수 내에 존재하는 name과 job은 속성이고, move()는 메소드이다. 이 때 속성은 생성되는 인스턴스마다 다른 값을 적용해야 하므로 개별 영역이 필요하다. 하지만 메소드는 모든 인스턴스가 함께 쓰는 ‘공용체’이기 때문에 인스턴스의 속성으로 상속받기 보다는 별도 공간인 프로토타입에 정의하는 것이 좋다. 프로토타입 속성으로 정의하면 모든 인스턴스에서 하나의 프로토타입 속성만을 참조하기 때문에 인스턴스별로 중복되는 공간을 낭비하지 않을 수 있다. 따라서 속성은 ‘생성자 함수’에, 메소드는 ‘프로토타입 속성’으로 정의하는 것이 좋다. 위의 코드를 아래와 같이 수정하자. 12345678910111213141516//생성자 함수function Character(name, job) &#123; this.name = name; this.job = job;&#125; //프로토타입으로 메소드 생성Character.prototype.move = function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`);&#125; //객체 인스턴스var char1 = new Character('루이스', '기사'); //메소드 실행char1.move(); 그런데 추가해야 할 메소드가 많을 경우, 함수식으로 작성하면 너무 장황해진다. 메소드가 많을 경우에는 아래와 같이 작성하자. 123456789101112131415161718192021222324252627282930//생성자 함수function Character(name, job) &#123; this.name = name; this.job = job;&#125; //프로토타입으로 메소드 생성Character.prototype = &#123; move: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; 캐릭터 이동&lt;br/&gt;`); &#125;, attack: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 공격&lt;br/&gt;`); &#125;, escape: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 도망&lt;br/&gt;`); &#125;, dead: function() &#123; document.write(`$&#123;this.name&#125; $&#123;this.job&#125; (이)가 사망&lt;br/&gt;`); &#125;&#125; //객체 인스턴스var char1 = new Character('루이스', '기사'); //메소드 실행char1.move();char1.attack();char1.escape();char1.dead();","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 클로저(Closure)","slug":"JavaScript/JS-자바스크립트-클로저-Closure","date":"2018-05-22T13:02:39.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/22/JavaScript/JS-자바스크립트-클로저-Closure/","link":"","permalink":"https://jess2.github.io/2018/05/22/JavaScript/JS-자바스크립트-클로저-Closure/","excerpt":"","text":"클로저(Closure)클로저는 유효범위(Scope)를 기억하는 함수이다. 따라서 내부함수가 외부함수의 지역변수를 기억하여 접근할 수 있다. 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수는 외부함수의 지역변수에 접근할 수 있다. 다시 말해서, 클로저란, 내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는 특성을 의미한다. 유효범위(scope)클로저에 대해 더 자세히 알아보기 전에 유효범위에 대해 알아보자. 변수는 크게 지역변수와 전역변수가 있다. 지역변수는 함수 내에서만 생명을 가지고, 함수가 종료되면 함수 내의 변수는 사라진다. 이렇게 함수 단위의 지역으로 변수의 유효 범위가 정해지는 것을 유효 범위(scope)라고 한다. 유효범위 Example1234567891011var global = 20; // 전역변수 function func() &#123; var local = 10; // 지역변수 document.write(global + '&lt;br&gt;'); // 출력결과 &gt; 20 document.write(local + '&lt;br&gt;'); // 출력결과 &gt; 10&#125; func();document.write(global + '&lt;br&gt;'); // 출력결과 &gt; 20document.write(local + '&lt;br&gt;'); // 출력결과 &gt; error 함수 밖의 전역 변수 global은 코드 전체에서 값이 유효하지만 함수 내의 지역 변수인 local은 함수 밖에서 사용할 수 없다. 함수가 종료되면 지역 변수의 유효범위가 종료되기 때문이다. 그러나 함수가 종료되어도 변수를 유지시킬 수 있는데, 그 방법이 바로 클로저이다. 클로저 Example123456789101112131415function outFunc() &#123; var value = 0; //내부 함수(클로저) function inFunc() &#123; return value += 1; &#125; return inFunc;&#125; var test = outFunc();document.write(test() + '&lt;br&gt;'); // 1document.write(test() + '&lt;br&gt;'); // 2document.write(test() + '&lt;br&gt;'); // 3 (줄 12) : 클로저 함수를 리턴받아 새로운 변수에 대입하면 outFunc()가 종료된 후에도 해당 함수의 지역변수 값을 계속 참조하고 변수 값이 생존하게 된다. 클로저 Example2123456789function outer() &#123; var title = 'hello world'; return function() &#123; alert(title); &#125;&#125; inner = outer();inner(); 8행에서 outer함수가 호출되었고, 그 결과가 inner변수에 담겼다. 그리고 9행으로 넘어오면 outer함수는 종료되었기 때문에 이 outer함수의 지역변수인 title은 소멸되는 것이 자연스럽다. 하지만 9행에서 inner함수를 호출했을 때, hello world가 잘 출력된다. 이것은 외부함수의 지역변수인 title이 소멸되지 않았다는 것이다. 이처럼 내부함수가 외부함수의 지역변수에 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸되지 않는다. for문과 클로저for문으로 클로저를 생성할 경우 실수가 빈번하게 발생한다. 다음 코드를 보자. 1234567891011var arr = []; for(var i=0; i&lt;3; i++) &#123; arr[i] = function() &#123; return i; &#125;&#125; document.write(arr[0]() + '&lt;br&gt;'); // 3document.write(arr[1]() + '&lt;br&gt;'); // 3document.write(arr[2]() + '&lt;br&gt;'); // 3 위 코드는 3만 세 번 출력한다. 클로저를 사용하려면 아래의 코드처럼 수정하자. 12345678910111213var arr = []; for(var i=0; i&lt;3; i++) &#123; (function(index)&#123; arr[index] = function() &#123; return index; &#125; &#125;)(i); // 익명 함수&#125; document.write(arr[0]() + '&lt;br&gt;'); // 0document.write(arr[1]() + '&lt;br&gt;'); // 1document.write(arr[2]() + '&lt;br&gt;'); // 2 위 코드는 정상적으로 0, 1, 2를 출력한다. for문 안의 처리문을 즉시 실행 익명 함수로 분리시키고 클로저가 for문의 i가 아닌 익명함수의 index변수를 참조하도록 한다. 참고로 ECMAScript 2015 (ES6)의 새로운 변수 선언문인 let 키워드로 변수를 선언하면 변수의 스코프가 블록 단위(기존 JS는 함수 단위이다.)로 엄격해지므로 이러한 문제가 발생하지 않는다. 아래의 코드를 보자. 1234567891011let arr = []; for(let i=0; i&lt;3; i++) &#123; arr[i] = function() &#123; return i; &#125;&#125; document.write(arr[0]() + '&lt;br&gt;'); // 0document.write(arr[1]() + '&lt;br&gt;'); // 1document.write(arr[2]() + '&lt;br&gt;'); // 2","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 크로스 도메인(Cross Domain)","slug":"JavaScript/JS-크로스-도메인-Cross-Domain","date":"2018-05-22T12:56:56.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/22/JavaScript/JS-크로스-도메인-Cross-Domain/","link":"","permalink":"https://jess2.github.io/2018/05/22/JavaScript/JS-크로스-도메인-Cross-Domain/","excerpt":"","text":"자바스크립트 크로스 도메인(Cross Domain) 이슈우선, 크로스 도메인이란 무엇인지 알아보자. 크로스 도메인은 쉽게 말해서 서로 다른 도메인 간의 호출이다. 만약, 내가 개발한 웹사이트에서만 사용하기 위해 API 서버를 구축하였는데, 다른 웹 서비스에서 이 API 서버에 마음대로 접근하여 API를 호출하여 사용한다면 큰 문제가 된다. 그래서 JavaScript는 Same Origin Policy(동일 출처 정책)라는 정책을 두어, 다른 도메인의 서버에 요청하는 것을 차단시킨다. 즉, JavaScript는 동일한 도메인 내에서만 서버 요청을 허용한다는 것이다. 따라서 JavaScript를 이용하여 AJAX를 통해 다른 도메인의 서버의 URL을 호출하여 데이터를 가져올 수는 없다. 예를 들어 www.naver.com 도메인에서 호출된 AJAX는 www.naver.com 도메인 내에 있는 URL만을 호출할 수 있고, www.naver.com 도메인에서 www.google.com 의 URL을 AJAX로 호출할 수 없다. 하지만, 크로스 도메인을 허용해야 하는 경우가 있다.예를 들어 하나의 웹 사이트에서는 효율성이나 성능 등의 이유로 각 기능별로 여러 서버를 두는 경우가 많다. (API 서버, WAS 서버, 파일 서버 등) 그런데 이 서버들은 물리적으로 분리된 서버이고, 다른 용도로 구축된 서버이기 때문에 당연히 각각 다른 도메인을 가진 서버들이다. 그래서 크로스 도메인 이슈가 발생하기 때문에 서로 간의 AJAX 통신을 할 수가 없다. 그래서 크로스 도메인을 허용해야만 한다. 그렇다면, 크로스 도메인은 어떻게 허용해야 할까? CORS를 활성화 시키면 된다. CORS란, Cross-Origin Resource Sharing의 약자로, 웹 페이지의 제한된 자원을 외부 도메인에서의 요청(접근)을 허용해주는 것이다. CORS를 이용하여 특정 도메인에서 접근하는 것이 가능하도록 해준다. 즉, 크로스 도메인을 허용해준다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] null과 undefined 비교","slug":"JavaScript/JS-null과-undefined-비교","date":"2018-05-22T12:41:34.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/22/JavaScript/JS-null과-undefined-비교/","link":"","permalink":"https://jess2.github.io/2018/05/22/JavaScript/JS-null과-undefined-비교/","excerpt":"","text":"null과 undefined 비교null과 undefined는 비슷해보이지만 엄연히 다르다. 이 두 개의 개념 차이를 명확히 알아두자. undefined먼저 undefined에 대해 알아보자. undefined는 변수를 선언만 하고 값을 할당하지 않은 것. 즉, 자료형이 결정되지 않은 상태이다. 123var a;document.write(a); // 출력결과 &gt; undefineddocument.write(typeof a); // 출력결과 &gt; undefined 위의 예시를 보면, a라는 변수를 선언만하고 값을 할당하지 않았기 때문에, 변수 a를 출력하면 undefined가 출력되고, 변수 a의 자료형이 결정되지 않은 상태이기 때문에, 변수 a의 type을 출력해도 undefined가 출력된다. null반면에 null은 변수를 선언하고, null이라는 빈 값을 할당한 것이다. 123var b = null; // null이라는 빈 값을 할당했다.document.write(b); // 출력결과 &gt; nulldocument.write(typeof b); // 출력결과 &gt; object 위의 예시를 보면 b라는 변수를 선언한 후, null이라는 값을 할당했다. null값은 객체로 취급되기 때문에, 변수 b를 출력하면 null이 출력되고, 변수 b의 type을 출력하면 object가 출력된다. null == undefined의 결과는 true아니, 지금까지 null과 undefined는 다른 것이라고 설명해 놓고 null == undefined의 결과는 왜 true인가? 12document.write(null == undefined); // 출력결과 &gt; truedocument.write(null === undefined); // 출력결과 &gt; false 비교 연산자 ==는 자료형이 다르면 자동 형변환으로 자료형을 강제로 맞춰서 비교한다. 따라서 undefined와 null은 자료형이 다르니 자바스크립트 엔진에서 자동으로 자료형을 강제로 맞춘 후, 둘 다 값이 없는 것이라는 사실을 확인하기 때문에 true를 반환한다. 반면에, 비교 연산자 ===는 자료형까지 동일한지 비교하기 때문에 null === undefined는 false를 반환한다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[ES6] var, let, const 비교","slug":"ECMAScript6/ES6-var-let-const-비교","date":"2018-05-21T14:50:55.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/21/ECMAScript6/ES6-var-let-const-비교/","link":"","permalink":"https://jess2.github.io/2018/05/21/ECMAScript6/ES6-var-let-const-비교/","excerpt":"","text":"var, let, const 비교기존 자바스크립트의 변수 선언 키워드 var과 ES6에서 새롭게 도입된 변수 선언 키워드 let과 const에 대해서 알아보자. var 키워드를 붙이지 않으면 어떻게 될까?먼저 var에 대해서 알아보자. var는 키워드 없이 변수를 선언하면 전역 변수가 된다. 전역 유효범위에 속해지기 때문에 코드 내에서 어디서든 변수에 접근할 수 있게 되는 것이다. 1234567891011function checkscope()&#123; var name = \"local\"; //var 키워드를 사용하여 변수를 선언&#125; function checkscope2()&#123; name2 = \"global\"; //var 키워드를 사용하지 않고 변수를 선언&#125; checkscope();checkscope2();document.write(name + \" \" + name2); //출력결과 &gt; global 위의 예제에서 var 키워드를 사용하여 선언한 변수인 name은 checkscope라는 함수 안에서의 지역변수이다. 하지만 var 키워드를 사용하지 않고 선언한 변수인 name2는 전역변수이다. 따라서 함수 밖에서 checkscope()와 checkscope2()함수를 호출한 후, name과 name2를 출력하면 name2의 값인 global만 출력되는 것을 확인할 수 있다. 변수 name은 함수의 지역변수이기 때문에 함수 밖에서는 사용할 수가 없지만 name2는 var 키워드를 붙이지 않아서 전역 변수가 되었기 때문에 함수 밖에서도 사용할 수 있다. Function-Scoped / Block-Scopedvar는 function-scoped이고, let과 const는 block-scoped이다. var는 function-scoped먼저 아래의 예시를 살펴보자. Example11234for(var i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 Example212345var i;for(i=0; i&lt;10; i++) &#123; console.log('i', i);&#125;console.log('after loop i is', i); //실행결과 &gt; after loop i is 10 var i가 hoisting 되기 때문에 위의 Example1과 Example2는 동일한 코드라고 보면 된다. 따라서 i는 for문 밖에서도 사용할 수 있는 전역변수인 것이기 때문에 after loop i is 10라는 문장이 정상적으로 출력이 된다. (참고로, 호이스팅에 대한 내용은 여기에서 볼 수 있다.) 하지만 아래의 예시에서는 에러가 발생한다. Example3과 Example4는 동일한 코드라고 보면 되는데, Example3에서 선언된 변수가 포함된 scope 내에서 가장 위로 호이스팅 된 것이 Example4이다. 그런데 이 var i는 counter라는 함수 내에 존재하기 때문에, 함수 밖에서는 이 i라는 변수를 사용할 수가 없다. Example31234567function counter() &#123; for(var i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example412345678function counter() &#123; var i; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; ReferenceError: i is not defined Example1~4를 다시 살펴보자. 왜 Example1에서는 전역에서 i에 접근할 수 있고 Example2에서는 전역에서 i에 접근할 수 없는가? var 키워드가 function-scoped이기 때문이다! 변수 선언문이 호이스팅될 때 해당 scope의 가장 위로 호이스팅되는데, Example1에서는 변수 선언문이 함수 안에 포함되어 있지 않아서 전역으로 호이스팅되는 것이고, Example3에서는 변수 선언문이 함수 안에 포함되어 있기 때문에 함수 안에서 가장 위로 호이스팅 된다. var 키워드를 사용하지 않으면? 앞에서 var 키워드를 사용하지 않으면 전역 변수가 된다고 했다. 따라서 아래와 같이 전역에서 i에 접근할 수 있기 때문에 after loop i is 10라는 문장이 정상적으로 출력된다. 아래의 Example5와 Example6는 동일한 코드라고 보면 된다. Example51234567function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 Example612345678var i;function counter () &#123; for(i=0; i&lt;10; i++) &#123; console.log('i', i); &#125;&#125;counter();console.log('after loop i is', i); // 실행결과 &gt; after loop i is 10 var / let / const var는 재선언과 재할당 모두 가능 let은 재선언 불가능, 재할당 가능 const는 재선언과 재할당 모두 불가능 var는 재선언 가능1234var a = 'hello';var a = 'world'; console.log(a); // 실행결과 &gt; world var는 재할당 가능1234var b = 'hello';b = 'world'; console.log(b); // 실행결과 &gt; world let은 재선언 불가능1234let c = 'hello';let c = 'world'; console.log(c); // 실행결과 &gt; Uncaught SyntaxError: Identifier 'c' has already been declared let은 재할당 가능1234let d = 'hello';d = 'world'; console.log(d); // 실행결과 &gt; world const는 재선언 불가능1234const e = 'hello';const e = 'world'; console.log(e); //Uncaught SyntaxError: Identifier 'e' has already been declared const는 재할당 불가능1234const f = 'hello';f = 'world'; console.log(f); //Uncaught SyntaxError: Assignment to constant variable.(상수 변수에 대입)","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"ECMAScript6","slug":"FrontEnd/ECMAScript6","permalink":"https://jess2.github.io/categories/FrontEnd/ECMAScript6/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://jess2.github.io/tags/ECMAScript6/"}]},{"title":"[Node] 노드의 기본 모듈 - url / fs / http","slug":"Node.js/Node-js-노드의-기본-모듈","date":"2018-05-18T16:01:42.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/19/Node.js/Node-js-노드의-기본-모듈/","link":"","permalink":"https://jess2.github.io/2018/05/19/Node.js/Node-js-노드의-기본-모듈/","excerpt":"","text":"노드의 기본 모듈 - url / fs / http1. URL 모듈노드에서는 url 모듈을 사용하여 사이트 주소 정보를 url 객체로 만들 수 있다. url 모듈을 사용하면 일반 주소 문자열을 url 객체로 만들거나 url 객체에서 일반 문자열로 변환하는 일을 쉽게 할 수 있다. url 모듈을 이용해 주소 문자열을 객체로 만들면 문자열 안에 있던 각각의 정보를 나누어 그 객체의 속성으로 보관한다. (ex. protocol / host / query) 따라서 요청 프로토콜이 http인지 https인지를 구별하거나 요청 파라미터를 확인하고 싶다면 url 객체가 갖고 있는 속성 값을 확인하면 된다. 아래의 코드를 보자. Example12345678910var url = require('url');//주소 문자열을 URL 객체로 만들기var curURL = url.parse('https://search.naver.com/search.naver?where=nexearch&amp;sm=top_hty&amp;fbm=1&amp;ie=utf8&amp;query=node');//URL 객체를 주소 문자열로 만들기var curStr = url.format(curURL);console.log('주소 문자열 : ' + curStr);console.log(curURL); (줄 1) : url 모듈을 사용하기 위해 require() 메소드를 호출했다. url 모듈을 로딩한 후 url이라는 변수 할당했다. (줄 4) : parse()메소드를 사용해 주소 문자열을 파싱하여 url 객체를 만들었다. (줄 7) : format()메소드를 사용해 URL 객체를 주소 문자열로 변환했다. 실행결과 파일을 실행하면 위와 같이 주소 문자열 정보와 URL 객체에 들어있는 속성들이 출력된다. 2. File System 모듈fs 모듈을 사용하면 파일 시스템에 접근할 수 있다. 메소드 이름 설명 readFile(filename, [encoding], [callback] 비동기식 IO로 파일을 읽어 들인다. readFileSync(filename, [encoding]) 동기식 IO로 파일을 읽어 들인다. writeFile(filename, data, encoding=’utf8’, [callback]) 비동기식 IO로 파일을 쓴다. writeFileSync(filename, data, encoding=’utf8’) 동기식 IO로 파일을 쓴다. 동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 동기식 IO로 읽어들인다.var data = fs.readFileSync('./package.json', 'utf8');console.log(data);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFileSync() 메소드를 사용하여 파일을 동기식 IO로 읽어드렸다. 동기식 IO로 파일 읽기 실행결과 파일을 동기식 IO로 읽어드렸기 때문에 파일을 전부 읽어서 출력한 후 ‘읽기 끝’을 출력하였다. 비동기식 IO로 파일 읽기12345678var fs = require('fs');//파일을 비동기식 IO로 읽어들인다.fs.readFile('./package.json', 'utf8', function(err, data) &#123; console.log(data);&#125;);console.log('읽기 끝'); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 readFile() 메소드를 사용하여 파일을 비동기식 IO로 읽어드렸다. 비동기식 IO로 파일 읽기 실행결과 파일을 비동기식 IO로 읽어드렸기 때문에 파일을 전부 읽기 전에 ‘읽기 끝’을 출력하였다. 이번엔 fs 모듈을 사용하여 파일을 직접 작성해보자. 비동기식 IO로 파일 쓰기12345678910var fs = require('fs');//파일에 데이터를 쓴다.fs.writeFile('./output.txt', 'Hello world!', function(err) &#123; if(err) &#123; console.log('Error: ' + err); &#125; console.log('output.txt 파일에 데이터 쓰기 완료');&#125;); fs 모듈을 사용하기 위해 require() 메소드를 호출했고 writeFile() 메소드를 사용하여 비동기식 IO로 파일에 데이터를 썼다. 파일을 직접 열고 닫으면서 읽거나 쓰기실제로 파일을 읽거나 쓸 때는 한꺼번에 모든 데이터를 읽거나 쓰지 않고 조금씩 읽거나 쓰는 방식을 사용하는 경우도 많다. 또한 다른 곳에서 받아 온 데이터를 파일에 쓰는 경우도 있기 때문에 파일을 다루는 다양한 방식이 따로 정의되어 있다. 메소드 이름 설명 open(path, flags, [mode], [callback]]) 파일을 연다. read(fd, buffer, offset, length, position, [callback]) 지정한 부분의 파일 내용을 읽어 들인다. write(fd, buffer, offset, length, position, [callback]) 파일의 지정한 부분에 데이터를 쓴다. close(fd, [callback]) 파일을 닫는다. 12345678910111213141516var fs = require('fs');fs.open('./output.txt', 'w', function(err, fd) &#123; if(err) throw err; var buf = new Buffer('안녕\\n'); fs.write(fd, buf, 0, buf.length, null, function(err, written, buffer) &#123; if(err) throw err; console.log(err, written, buffer); fs.close(fd, function() &#123; console.log('파일 열고 데이터 쓰고 파일 닫기 완료'); &#125;); &#125;);&#125;); 파일을 열기 위해 open()메소드를 호출할 때 세 개의 파라미터가 전달되었다. 첫 번째 파라미터는 파일의 이름, 두 번째 파라미터는 파일을 읽거나 쓰기 위한 플래그이다. 대표적인 플래그의 종류에 대해 알아보자. flags 설명 r 읽기에 사용하는 플래그이다. 파일이 없으면 예외가 발생한다. w 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. w+ 읽기와 쓰기에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용을 모두 삭제한다. a+ 읽기와 추가에 사용하는 플래그이다. 파일이 없으면 만들어지고 파일이 있으면 이전 내용에 새로운 내용을 추가한다. 3. HTTP 모듈http 모듈은 노드의 가장 기본적인 모듈이며, http 서버와 클라이언트를 생성하는 것과 관련된 모든 기능을 담당한다. 웹 서버의 생성과 실행1234567891011121314//서버를 생성var http = require('http');var server = http.createServer();//서버를 실행server.listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;);//10초 후 서버 종료setTimeout(function() &#123; console.log('서버 종료'); server.close();&#125;,10000); http 모듈을 사용하기 위해 require()메소드를 호출했고 createServer()메소드를 이용해서 서버를 생성했다. listen()메소드를 이용해서 서버를 실행했고 close()메소드를 이용해서 서버를 종료했다. response 객체위의 예제에서 서버를 실행한 후 http://127.0.0.1:52273 에 접속해도 웹 브라우저에는 아무것도 출력되지 않을 것이다. 요청만 하고 응답을 하지 않았기 때문이다. 클라이언트에 웹 페이지를 제공하려면 응답 메시지를 작성해야 한다. 응답 메시지를 작성할 때는 response 객체를 생성한다. 123456require('http').createServer(function(request, response) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end('&lt;h1&gt;hello web server with node.js&lt;/h1&gt;');&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;); 코드를 실행한 후 http://127.0.0.1:52273 에 접속하면 웹 브라우저에 아래와 같이 출력된다. 그러나 자바스크립트 파일 위에서 모든 html 페이지를 문자열로 작성하는 것은 매우 비효율적이다. 그 대신 File System 모듈을 사용하여 서버에 존재하는 html 페이지를 클라이언트에 제공할 수 있다. File System 모듈을 사용한 html 페이지 제공1234567891011121314//모듈을 추출한다var fs = require('fs');var http = require('http');//웹 서버를 생성하고 실행한다http.createServer(function(request, response) &#123; //html 파일을 읽는다 fs.readFile('htmlPage.html', function(error, data) &#123; response.writeHead(200, &#123;'content-type': 'text/html'&#125;); response.end(data); &#125;);&#125;).listen(52273, function() &#123; console.log('Server Running at http://127.0.0.1:52273');&#125;) fs 모듈과 http 모듈을 사용하기 위해 require() 메소드를 호출했고 createServer()메소드로 웹 서버를 생성했다. 그 후, readFile()메소드로 htmlPage.html파일을 읽어와서 응답 메시지를 작성했다. htmlPage.html파일은 아래와 같이 작성했다. 12&lt;h1&gt;This is htmlPage&lt;/h1&gt;&lt;p&gt;Hello world! I'm Jessie&lt;/p&gt; 실행결과","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Node.js","slug":"BackEnd/Node-js","permalink":"https://jess2.github.io/categories/BackEnd/Node-js/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node] 노드의 특징","slug":"Node.js/Node-js-노드의-특징","date":"2018-05-18T13:36:09.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/18/Node.js/Node-js-노드의-특징/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node.js/Node-js-노드의-특징/","excerpt":"","text":"노드의 특징노드(Node.js)는 JavaScript를 이용해서 서버를 만들 수 있는 개발 도구다. 하나의 언어로 Front-end와 Back-end를 모두 다룰 수 있다니, 이 얼마나 매력적인가! 그럼 이 매력적인 노드의 특징에 대해서 본격적으로 살펴보자. 1. 빠른 개발 가능노드의 첫 번째 특징으로는 빠른 개발이 가능하다는 것이다. Javascript 기반이고 개발 구조가 단순화 되어 있어서 빠르게 개발이 가능하다. 또한 클라이언트에서 자바스크립트로 front-end를 개발하던 FE 개발자들도 손쉽게 서버 프로그래밍이 가능하다. 한 마디로, 하나의 언어로 애플리케이션 전체를 구현할 수 있기 때문에 개발을 빠르게 할 수 있는 것이다. 또한 socket.io를 이용한 웹 push 구현이 매우 쉽게 가능하다. 웹 브라우저의 종류에 따라서 push 메커니즘을 자동으로 선택하여 사용하고 있으며 이러한 push 메커니즘은 socket.io API 내에 추상화 되어 있기 때문에 어떤 기술로 구현이 되어 있든 개발자 입장에서는 socket.io만 쓰면 간단하게 웹 기반의 push 서비스가 구현이 가능하다. 2. 모듈과 패키지소스 파일 하나에 실행하려는 기능이 모두 들어 있다면 코드가 굉장히 복잡해질 것이다. 그래서 메인이 되는 자바스크립트 파일을 두고, 일부 기능만 담당하는 코드를 별도의 파일로 만들 수 있는데 이것을 모듈(Module)이라고 한다. 모듈 안에 있는 코드를 사용하고 싶다면 require() 함수로 모듈을 호출하면 된다. 이렇게 불러들인 모듈은 자바스크립트 객체로 인식되며, 그 객체를 참조하여 모듈에 넣어둔 기능을 사용할 수 있다. 또한, 여러 개의 모듈을 합쳐서 하나의 패키지(Package)로 만들어 두면 다른 개발자들도 npm 프로그램으로 손쉽게 이 패키지를 설치하여 사용할 수 있다. 3. 비동기 입출력(Non-Blocking IO)하나의 요청 처리가 끝날 때까지 기다렸다가 그 다음 요청 처리를 해야 한다면 굉장히 비효율적일 것이다. 노드는 하나의 요청 처리가 끝날 때까지 기다리지 않고 다른 요청을 동시에 처리할 수 있는 비동기 입출력(Non-Blocking IO) 방식을 적용했다. 그럼 프로그램에서 작업을 진행하는 중간에 다른 작업을 어떻게 진행할 수 있는 것일까? 프로그램에서 다른 작업을 처리할 수 있는 시점이 되면 콜백 함수(Callback Function)을 호출한다. 따라서 파일 읽기 작업을 할 때, 프로그램이 파일 읽기 작업이 끝날 때까지 대기하지 않아도 파일을 다 읽은 시점에 통보를 받고 파일의 내용을 화면에 보여준다. 이렇게 콜백 함수를 이용하기 때문에 비동기 입출력 방식은 대기 시간이 필요 없고 속도가 빠르다. 4. 이벤트 기반 입출력자바스크립트는 코드를 한 줄씩 해석하면서 실행하는 인터프리터(Interpreter) 방식을 사용하기 때문에 속도가 느려서 문제였는데, 이 문제는 크롬의 V8 자바스크립트 엔진이 나오면서 해결되었다. V8 엔진은 자바스크립트 코드를 네이티브 코드로 바꾼 후 실행할 수 있는데, 노드는 이 V8 엔진을 이용해 자바스크립트 코드를 빠르게 실행할 수 있다. 노드를 설치한 다음 노드로 프로그램을 만들어 실행하면 크롬 V8 엔진 위에서 실행된다. 그런데 이 V8 엔진에서 동작하는 노드의 아키텍처에서 가장 중요한 부분 중 하나가 이벤트를 받아 처리하는 기능이다. 노드에는 이벤트를 보내고 받을 수 있도록 EventEmitter라는 것이 만들어져 있다. 노드의 객체는 EventEmitter를 상속받을 수 있으며 상속받은 후에는 EventEmitter 객체의 on()과 emit() 등의 메소드를 사용할 수 있다.","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Node.js","slug":"BackEnd/Node-js","permalink":"https://jess2.github.io/categories/BackEnd/Node-js/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node] 노드로 만들 수 있는 서버","slug":"Node.js/Node-노드로-만들-수-있는-서버","date":"2018-05-18T12:04:34.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/18/Node.js/Node-노드로-만들-수-있는-서버/","link":"","permalink":"https://jess2.github.io/2018/05/18/Node.js/Node-노드로-만들-수-있는-서버/","excerpt":"","text":"노드로 만들 수 있는 서버노드의 등장으로 인해 웹 브라우저에서 동작하는 JavaScript를 이용하여 서버까지 구현이 가능해졌다. 하나의 언어로 애플리케이션 전체를 구현할 수 있게 된 것이다. 서버가 뭔데? 다른 곳에 있는 단말에 데이터를 달라고 요청하는 프로그램을 클라이언트(Client), 다른 곳에서 요청받은 명령을 처리해주는 프로그램을 서버(Server)라고 한다. 이때 서버는 포트(Port)를 지정하여 그 포트로 요청을 받을 수 있다. 서버를 만들어 실행하면 지정된 포트에서 클라이언트로부터 요청을 받아 처리한다. 또한 대부분의 서버는 데이터베이스에 연결할 수 있도록 구성되기 때문에 클라이언트에서 보내온 데이터를 저장하거나 저장된 데이터를 조회한 후 클라이언트에 보내준다. 굉장히 다양한 서버의 유형 중에서 우리가 많이 사용하는 웹 브라우저에서 접속하는 서버를 웹 서버라고 하며, HTTP 프로토콜을 사용한다. 그럼 웹 서버 말고 또 어떤 서버가 있을까? 만들려는 애플리케이션이 무엇인지에 따라 필요한 서버 유형이 달라진다. 웹 서버, 채팅 서버, 모바일 서버 등 서버의 유형은 굉장히 다양하지만 우리는 웹 브라우저에서 웹 문서를 요청할 때 필요한 기능을 수행하는 웹 서버에 대해서 알아보자. 노드로 웹 서버를 만들자Node.js에서 제공하는 다양한 모듈(Module)을 사용하여 웹 서버를 만들 수 있다. 익스프레스(Express) 몽고디비(MongoDB) 뷰 탬플릿(View Template) 패스포트(Passport) 웹 프레임워크인 익스프레스(Express)가 웹 서버에 필요한 파일들을 자동으로 만들어주기 때문에 익스프레스로 기본 구조를 만들고, 몽고디비(MongoDB)를 이용해서 데이터를 저장하거나 조회할 수 있다. 뷰 탬플릿(View Template)은 클라이언트에 응답을 보낼 때 사용하려고 미리 웹 문서의 원형(Template)을 만들어 놓은 것이며, 패스포트(Passport)는 사용자 로그인이나 회원가입을 위해 사용한다.","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Node.js","slug":"BackEnd/Node-js","permalink":"https://jess2.github.io/categories/BackEnd/Node-js/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[Node] 노드의 소개","slug":"Node.js/Node-js-노드의-소개","date":"2018-05-17T13:58:48.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/17/Node.js/Node-js-노드의-소개/","link":"","permalink":"https://jess2.github.io/2018/05/17/Node.js/Node-js-노드의-소개/","excerpt":"","text":"Node.js 소개1. 자바스크립트 인터프리터자바스크립트 언어는 컴파일러가 실행 파일을 생성하는 컴파일 방식의 언어가 아니고 인터프리터가 소스코드를 읽으면서 실행하는 인터프리터 방식의 언어이다. 자바스크립트 인터프리터는 웹브라우저에 내장되어 있기 때문에 웹페이지에 포함된 자바스크립트 소스코드를 웹브라우저에 내장된 자바스크립트 인터프리터가 실행한다. 이와 마찬가지로 자바스크립트 소스코드를 서버에서 실행하려면 서버에도 자바스크립트 인터프리터가 필요하다. 2. 서버 사이드 자바스크립트 플랫폼서버에서 자바스크립트를 실행하기 위해 필요한 것들은 다음과 같다. 자바스크립트 인터프리터(자바스크립트 엔진) 자바스크립트 라이브러리 서버에서 자바스크립트를 실행하기 위해 자바스크립트 인터프리터와 자바스크립트 라이브러리를 통합해 놓은 것이 Node.js이다. 여기에서 자바스크립트 인터프리터를 자바스크립트 엔진이라고도 부른다. &lt;결론&gt;Node.js는 서버에서 자바스크립트를 실행하기 위한 환경이다.다시 말해서, Node.js는 서버 사이드 자바스크립트 플랫폼(Server Side JavaScript Platform)이다. 3. V8 EngineV8 엔진은 구글이 만든 오픈소스 자바스크립트 인터프리터의 이름이다. 구글 크롬 웹브라우저에 내장된 자바스크립트 인터프리터도 V8 엔진이고 Node.js에 내장된 자바스크립트 인터프리터도 V8 엔진이다. 4. Node.js는 웹 서버가 아니다.Node.js는 자바스크립트 인터프리터(엔진)와 자바스크립트 라이브러리를 결합한 것이다. 그런데 자바스크립트 라이브러리 중에 웹서버를 구현한 라이브러리도 있는데, 이 웹 서버를 구현한 자바스크립트 라이브러리를 Node.js에서 실행하면 웹 서버 기능이 실행되는 것이다. 그렇지만 Node.js가 웹 서버인 것은 아니다. 5. 비동기 I/O 처리Node.js의 주요 특징은 비동기 I/O 처리이다. I/O란?입력/출력(Input/Ouput)을 짧게 I/O라고 부른다. 대표적인 I/O 작업은 다음과 같다. 하드디스크에 읽기/쓰기 네트워크 데이터 받기/보내기 대표적인 I/O 장치는 다음과 같다. 하드디스크 네트워크 카드 CPU의 지시에 의해서 I/O 작업이 시작되지만 I/O 작업을 직접 실행하는 것은 I/O 장치이다. I/O 작업이 완료되면 I/O 장치는 CPU에게 작업 완료를 통보한다. 이 통보를 I/O Interrupt라고 부른다. 동기 I/O 처리아래의 예시를 보자. 123String data = inputStream.read();System.out.println(data);System.out.println(\"완료\"); 위 코드는 동기 방식 I/O 작업을 Java로 구현한 것이다. 다음과 같은 순서로 실행된다. inputStream.read() 읽기 작업을 실행한다. 읽기 작업이 완료된 후에 read메소드가 리턴한다. 이 메소드의 리턴 값은 읽은 데이터이다. 읽은 데이터가 화면에 출력된다. 출력이 완료된 후 println메소드가 리턴한다. 완료문자열이 화면에 출력된다. 출력이 완료된 후 println메소드가 리턴한다. 비동기 I/O 처리아래의 예시를 보자. 1234inputStream.readAsync( data -&gt; System.out.println(data));System.out.println(\"완료\"); 위 코드는 비동기 방식 I/O 작업을 Java로 구현한 것이다. 비동기 방식의 메소드는 작업을 시작하자마자 작업이 완료되기도 전에 즉시 리턴한다. 위 코드에서 readAsync메소드가 비동기 메소드이기 때문에 읽기 작업을 시작하자마자 읽기 작업이 완료되기도 전에 즉시 리턴한다. 읽기 작업이 완료되기 전에 리턴하는 것이라서 readAsync메소드는 읽은 결과를 리턴할 수 없다. 위 코드는 다음과 같은 순서로 실행될 것이다. inputStream.readAsync()읽기 작업이 시작된다. 읽기 작업이 시작 되자마자 readAsync메소드가 리턴한다. 완료 문자열이 화면에 출력된다. 출력이 완료된 후 println메소드가 리턴한다. 읽기 작업이 완료되고 data -&gt; System.out.println(data)부분이 실행된다. 읽은 데이터가 화면에 출력된다. 위 실행 순서는 확실하지 않다. 만약 읽기 작업이 매우 빨리 완료된다면 읽은 데이터가 화면에 출력된 이후에 완료문자열이 화면에 출력될 수도 있다. 6. 비동기 I/O 방식의 장단점장점쓰레드 한 개가 비동기 방식의 I/O 메소드를 실행할 때, I/O 작업이 완료될 때까지 쓰레드가 기다리지 않고 작업이 시작되자마자 즉시 리턴한다. 따라서 I/O 장치에서 I/O 작업이 처리되는 동안 쓰레드가 정지 상태로 대기하지 않고 다른 작업을 할 수 있다. 비동기 방식의 I/O 작업들을 동시에 여러 개 처리해야 한다면 비동기 I/O 메소드들을 여러 개 순서대로 호출하여 비동기 I/O 작업들을 동시에 여러 개 시작하면 된다. 따라서 멀티 쓰레드가 필요없다. 즉, 비동기 I/O 처리 방식의 장점은 멀티 쓰레드가 필요 없기 때문에 메모리 사용량도 적어서 효율적이라는 것이다. 단점비동기 메소드는 작업을 시작만 하고 즉시 리턴하기 때문에 작업 결과를 전달 받으려면 복잡한 프로그래밍 기법이 필요하며 비동기 작업이 완료된 시점에 처리할 작업을 구현할 때도 복잡한 프로그래밍 기법이 필요하다. 즉, 비동기 I/O 처리 방식의 단점은 어려운 프로그래밍 기법이 필요하다는 점이다.","categories":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/categories/BackEnd/"},{"name":"Node.js","slug":"BackEnd/Node-js","permalink":"https://jess2.github.io/categories/BackEnd/Node-js/"}],"tags":[{"name":"BackEnd","slug":"BackEnd","permalink":"https://jess2.github.io/tags/BackEnd/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jess2.github.io/tags/Node-js/"}]},{"title":"[JS] 이벤트 버블링과 이벤트 캡쳐링","slug":"JavaScript/JS-이벤트-버블링과-캡쳐링","date":"2018-05-16T10:06:13.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/16/JavaScript/JS-이벤트-버블링과-캡쳐링/","link":"","permalink":"https://jess2.github.io/2018/05/16/JavaScript/JS-이벤트-버블링과-캡쳐링/","excerpt":"","text":"Event Bubbling / Event Capturing버블링과 캡쳐링을 본격적으로 알아보기 전에 간단한 코드를 한 번 살펴보자. 1234&lt;div onclick=\"alert('The DIV handler!')\"&gt; DIV 태그 &lt;p&gt;P 태그&lt;/p&gt;&lt;/div&gt; See the Pen Ryewge by SoyeonJung (@je_ss2) on CodePen. div태그에 alert(&#39;The DIV handler!&#39;)라는 이벤트 핸들러를 할당하였고, p태그에는 어떠한 핸들러도 할당하지 않았다. 그런데 p태그를 클릭해도 div태그에 할당된 핸들러가 실행이 된다. 조금 이상하다.p태그를 클릭했는데 왜 div태그에 할당된 핸들러가 실행이 되는 것일까? 버블링 때문이다.자바스크립트의 이벤트 버블링 때문에 위의 코드에서 div태그 안에 있는 p태그를 클릭하면 div태그에 할당된 클릭 이벤트가 발생하는 것이다. 그럼, 버블링이 정확히 뭔데? 이벤트 버블링의 원리는 간단하다. “엘리먼트에 이벤트가 발생하면 먼저 해당 엘리먼트의 핸들러를 실행시킨 후, 그의 부모 엘리먼트의 핸들러를 실행시키고, 또 그 위의 조상 엘리먼트들의 핸들러를 실행시킨다” 마치 버블이 아래에서 위로 올라가는 것과 같아서 버블링이라고 한다. 아래의 예시를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"alert('p')\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJaNgQ by SoyeonJung (@je_ss2) on CodePen. form태그에는 alert(&#39;form&#39;)클릭 이벤트를 줬고, div태그에는 alert(&#39;div&#39;)클릭 이벤트를 줬고, p태그에는 alert(&#39;p&#39;)클릭 이벤트를 줬다. 그런데, p태그는 div태그가 감싸고 있고, 또 그 div태그는 form태그가 감싸고 있다. 따라서 이벤트 버블링으로 인해, p태그를 클릭하면 p -&gt; div -&gt; form순서로 알림창이 뜬다. 그리고 div태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. p태그를 클릭하면 window에서부터 p태그까지 요소 중간에 있는 이벤트들을 전부 검색해서 따로 메모리에 가지고 있다고 생각하면 된다. 해당 엘리먼트부터 차례대로 위로 올라가면서 이벤트들을 발생시키는 것, 그것이 바로 이벤트 버블링이다. 버블링 멈추기기본적으로 이벤트 버블링은 항상 발생한다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen WJabwo by SoyeonJung (@je_ss2) on CodePen. form태그와 div태그에만 이벤트 핸들러를 주고, p태그에는 이벤트 핸들러를 주지 않았다. 하지만, 이벤트 버블링으로 인해 p 태그를 클릭하면 div -&gt; form순서로 알림창이 뜬다. 이벤트 버블링이 발생되지 않았으면 좋겠어 이벤트 버블링은 event.stopPropagation()을 이용해서 간단하게 멈출 수 있다. 아래의 코드를 보자. 12345&lt;form onclick=\"alert('form')\"&gt;FORM &lt;div onclick=\"alert('div')\"&gt;DIV &lt;p onclick=\"event.stopPropagation()\"&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; See the Pen xjyGGK by SoyeonJung (@je_ss2) on CodePen. p태그에 onclick=&quot;event.stopPropagation()&quot;를 주었더니, p태그를 클릭해도 아까처럼 이벤트가 발생하지 않는다. 이벤트 버블링이 작동하지 않기 때문이다. 이벤트 캡쳐링그렇다면 이번에는 이벤트 캡쳐링에 대해서 알아보자. 이벤트 캡쳐링도 이벤트 버블링과 비슷하다. 버블링이 아래에서 위로 올라가는 것이라면, 캡쳐링은 위에서 아래로 내려가는 것이다. addEventListener를 이용하여 버블링과 캡쳐링에 대해서 살펴보자. capturing단계에서 이벤트를 catch하려면 addEventListener의 세 번째 요소를 true로 설정해줘야 한다. 기본적으로 addEventListener의 세 번째 요소를 작성하지 않으면 default값이 false인데, false로 설정할 경우, 핸들러는 버블링 단계로 설정된다. 반면에 true로 설정할 경우, 핸들러는 캡쳐링 단계로 설정된다. 먼저 addEventListener의 세 번째 요소를 작성하지 않았을 경우를 살펴보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName));&#125; See the Pen mLzywJ by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 P -&gt; DIV -&gt; FORM -&gt; BODY -&gt; HTML순서로 알림창이 열린다. addEventListener의 세 번째 요소를 작성하지 않아서 기본값인 false로 되었기 때문에 핸들러가 버블링 단계로 설정되었기 때문이다. 이번에는 addEventListener의 세 번째 요소를 true로 작성해보자. 12345&lt;form&gt;FORM &lt;div&gt;DIV &lt;p&gt;P&lt;/p&gt; &lt;/div&gt;&lt;/form&gt; 1234//JavaScript Codefor(let elem of document.querySelectorAll('*')) &#123; elem.addEventListener(\"click\", e =&gt; alert(elem.tagName), true);&#125; See the Pen WJabBd by SoyeonJung (@je_ss2) on CodePen. p태그를 클릭하면 HTML -&gt; BODY -&gt; FORM -&gt; DIV -&gt; P순서로 알림창이 열린다. addEventListener의 세 번째 요소를 true로 작성했기 때문에 핸들러가 캡쳐링 단계로 설정되었기 때문이다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] 호이스팅(Hoisting)","slug":"JavaScript/JS-호이스팅-Hoisting","date":"2018-05-15T15:43:24.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/16/JavaScript/JS-호이스팅-Hoisting/","link":"","permalink":"https://jess2.github.io/2018/05/16/JavaScript/JS-호이스팅-Hoisting/","excerpt":"","text":"자바스크립트의 호이스팅(Hoisting)Hoisting이란, 선언을 현재 스크립트 또는 현재 함수의 맨 위로 이동시키는 JavaScript의 기본 동작이다. 만약, 변수가 함수 내에서 정의되었을 경우 선언이 함수 내부의 최상위로 호이스팅되고, 함수 밖에 정의되었을 경우에는 선언이 전역 컨텍스트의 최상위로 호이스팅 된다. 호이스팅 때문에 변수를 선언하기 전에 사용할 수 있다. JavaScript에서는 변수를 선언하기 전에 사용할 수 있다. 아래에 선언을 해도 선언한 것이 Hoisting 되어 위로 끌어올려지기 때문이다. 아래의 Code-1과 Code-2는 동일한 코드라고 보면 된다. Code-1123456x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 var x; // x 선언 Code-212345var x; // x 선언x = 5; // x에 값을 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x; //출력 결과 &gt; 5 할당은 호이스팅하지 않고, 선언만 호이스팅한다.JavaScript는 Hoisting을 할 때, 선언만 Hoisting하고, 할당은 Hoisting을 하지 않는다. 다음 Code-3과 Code-4는 동일한 코드라고 보면 된다. Code-3123456var x = 5; // x를 선언하고 x에 5를 할당 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined var y = 7; // y를 선언하고 y에 7을 할당 Code-41234567var x = 5; // x를 선언하고 x에 5를 할당var y; // y를 선언 elem = document.getElementById(\"demo\");elem.innerHTML = x + \" \" + y; // 출력 결과 &gt; 5 undefined y = 7; // y에 7을 할당 위의 Code-3과 Code-4에서 y에 할당된 값인 7이 출력되지 않고 undefined가 출력되는 이유는, 선언만 위쪽으로 끌어 올려지고(Hoisting), 할당은 위로 끌어 올려지지 않기 때문이다. hosting으로 인해 y는 사용되기 전에 선언은 되었지만, 할당이 수행되지 않았기 때문에 y값은 undefined가 되는 것이다. Hosting은 많은 개발자에게 알려지지 않거나 간과 된 JavaScript의 동작인데, 개발자가 Hosting을 이해하지 못하면 프로그램에 버그가 있을 수 있다. 따라서, 버그를 피하려면 항상 모든 범위의 시작 부분에 모든 변수를 선언하고 할당해야 한다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[JS] onclick과 addEventListener 비교","slug":"JavaScript/JS-onclick과-addEventListener-비교","date":"2018-05-15T14:27:19.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/05/15/JavaScript/JS-onclick과-addEventListener-비교/","link":"","permalink":"https://jess2.github.io/2018/05/15/JavaScript/JS-onclick과-addEventListener-비교/","excerpt":"","text":"onclick과 addEventListener 비교자바스크립트에서 클릭 이벤트를 줄 때 어떤 방식을 사용하는가?onclick을 사용할 수도, addEventListener를 사용할 수도 있지만, 어떤 것을 사용하든 이 두 가지가 서로 어떻게 다른 지 알고 있어야 한다. onclick은 하나만, addEventListener는 여러 개를. onclick에는 하나의 콜백만 지정할 수 있지만, addEventListener를 사용하면 여러 개의 이벤트 리스너를 추가할 수 있다. 따라서 만약 onclick 이벤트 핸들러를 두 번 이상 사용한다면, 기존 이벤트 핸들러를 덮어쓰기 때문에 가장 아래에 추가한 핸들러만 제대로 작동한다. 반면, addEventListener는 기존 이벤트 핸들러를 덮어 쓰지 않고 얼마든지 계속해서 핸들러를 추가해도 모든 핸들러가 정상적으로 작동한다. 아래의 코드를 보자. ExampleSee the Pen onclick과 addEventListener 비교 by SoyeonJung (@je_ss2) on CodePen. btn에 onclick과 addEventListener 이벤트 핸들러를 각각 두 개씩, 총 네 개의 핸들러를 만들었지만, alert(&#39;onclick-1&#39;)는 실행되지 않고 나머지 세 개만 실행되는 것을 확인할 수 있다. 그럼 onclick은 왜 있는거야?이쯤 되면 이런 의문이 들 수 있다. 클릭 이벤트를 주고 싶으면 그냥 addEventListener를 사용하면 되지, onclick은 굳이 왜 만든 것일까? onclick은 초기 DOM Level-0에서 제공하던 기능이고, 그 이후 버전인 Level-2에서 추가된 것이 addEventListener이다. addEventListener는 이벤트 캡쳐링, 버블링 같은 이벤트 방식을 설정할 수 있기 때문에 이벤트 제어에 있어서 더욱 유용하지만, addEventListener는 IE8 이하에서는 작동을 하지 않는다. 그래서 구형 브라우저 지원이 필요하면 onclick을 사용하거나 다른 방법을 찾아야 한다.","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/categories/FrontEnd/"},{"name":"JavaScript","slug":"FrontEnd/JavaScript","permalink":"https://jess2.github.io/categories/FrontEnd/JavaScript/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://jess2.github.io/tags/FrontEnd/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://jess2.github.io/tags/JavaScript/"}]},{"title":"[2018. 3] Talk Concert with Kakao CEO 임지훈","slug":"etc/2018-3-Talk-Concert-with-Kakao-CEO-임지훈","date":"2018-03-14T10:18:53.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/03/14/etc/2018-3-Talk-Concert-with-Kakao-CEO-임지훈/","link":"","permalink":"https://jess2.github.io/2018/03/14/etc/2018-3-Talk-Concert-with-Kakao-CEO-임지훈/","excerpt":"","text":"Talk Concert with Kakao CEO 임지훈지난 3월 14일, 연세대학교 백양누리 그랜드볼룸에서 열린 Talk Concert에 다녀왔다. 토크 콘서트는 2017년 대학생이 뽑은 최고의 CEO 임지훈 카카오 대표님께서 맡아주셨는데, 듣는 내내 “성공한 사람은 다르구나”라는 걸 느꼈다. 어떤 황당한 질문을 받아도 능숙하게 답변해주시고 또 많은 것을 공유해주셨다. 약 300명의 대학생들이 모여 있으니 정말 다양한 질문들이 쏟아져나왔고, 나는 개인 일정 때문에 1시간 정도 늦게 참석해서 그 이후의 질문들에 대한 답변만 정리해보았다. 1. 다양한 사람들과 만나라.나와 비슷한 걸 알고 있고 비슷한 경험을 해본 사람들이 아닌, 다양한 사람들과 창업을 하거나 서비스를 만드는 것이 좋다. 서로 다른 경험을 한 사람들, 다양한 나이의 사람들과 만나라. 2. 한 명이 모든 일에 전부 관여하는 것은 좋은 방법이 아니다.한 명이 모든 일에 전부 관여하기 보다 팀원들이 각자의 일에 책임감을 갖고 일할 수 있도록 이끌어 주는 방법이 좋은 방법이다. 3. 짧은 경험을 많이 하라.우리 사회는 우리들에게 정답을 찾아서 살아가라는 압박을 준다. “꿈을 가져야 한다. 좋아하는 일을 해라”라는 압박에서 벗어나 자기주도적인 삶을 살자. 내가 선택하고 내가 후회하는 것이 낫다. 나머지는 정답이 없는 것 같다. 하지만 그 순간 순간에는 최선을 다해야 한다. 엄청난 꿈이 있어서 그 꿈대로 차근 차근 간 것이 아니다. 남이 뭐라고 하든 짧은 어떤 것들을 많이 경험해보고 돈 말고 의미 있는 것이 무엇일까 생각해보자. 4. 대화를 하면 그 사람이 보인다.30분 멋있게 프레젠테이션하는 것은 쉽지만 3~4시간 대화를 하는 것은 쉽지 않다. 대화를 하면 그 사람이 풀고자하는 문제에 대해서 충분한 역량을 가지고 있는지, 무언가를 하는 이유에 대해 충분히 알고 있는지, 자신만의 스토리가 있는지 알 수 있다. 5. 젊은 나이에 CEO가 될 수 있었던 것은 ‘운’ 때문이다.정말 큰 운이라고 생각하고 똑똑한 것이 성공의 원천이라고 생각하지 않는다. 운이라는게 세상에 존재한다고 생각하는 순간, 내가 틀릴 수 있다고 생각하게 되고, 겸손해진다. 특히 IT 업계에서는 성공과 실패에서 운이라는 게 정말 많이 작용한다. 실력은 기본 전제조건이고 실력과 운 두 가지 다 필요하다. 그리고 똑똑하다고 저 혼자 일하는 것이 아닌 팀으로서 일하고 모든 사람이 자신의 공을 느끼게 해준다면 좋은 사람들이 모이게 된다. 좋은 사람들이 모이면 운은 더 커진다. 요약하자면, 실력은 전제조건이며 다른 사람들과 함께 일하는 것을 잘하는 것이 중요하다. 6. 지금 스무살 대학생으로 돌아간다면 모든 기술에 오픈마인드로 공부할 것이다.스무살 대학생으로 돌아간다면 어떤 특정한 분야만 공부하지 않고 모든 기술에 오픈마인드로 공부할 것이다. 작년에 AI가 떴고 그 전에는 빅데이터가 떴고 80년대에는 전자산업, 70년대에는 중화학공업이 떴다. 기술은 계속해서 변화하고 지난 10년의 변화보다 앞으로의 10년의 변화가 더 클 것이기 때문에 기술로 인해서 세상이 바뀌는 것을 인정하고 항상 기술을 공부하려고 노력하면 어떤 분야로 가더라도 내공이 쌓일 것이다. 모든 기술에 대해 오픈마인드로 공부하자. 7. 취업하기 위한 자기소개서를 쓴다면 리뷰하는 사람을 생각해볼 것이다.자기소개서를 리뷰하는 사람들은 100개, 200개, 300개의 자기소개서를 읽을 것이다. 그 사람이 되어 생각해봤을 때 자기소개서를 어떻게 쓰면 좋을지 생각해보고 자신만의 답변을 생각해보자. 8. 가장 행복한 순간은 다른 사람들과 함께 일할 때이다.성공과 실패를 떠나서 우리가 정말 몰입해서 어떤 것을 했고 그 경험을 같이 하면서 이 사람들만의 동질감이 생길 때 카타르시스가 느껴진다. 치열하게 토론하는 그 순간들이 내가 살아있음을 느끼는 순간들이다. 9. 대표직에서 물러나기로 결정한 이유는 가슴이 뛰는 일을 하고싶기 때문이다.모든 사람은 각자의 장점이 있다고 생각한다. 대표직을 맡는 동안 많은 변화가 있었고 힘든 시기였지만, 현재는 대부분 A사업과 B사업을 조율하는 등 안정적인 상황인데 이 부분은 내가 가장 잘할 수 있는 게 아닐 수 있다고 생각한다. 개인적으로 카카오 CEO 대표직이 보람차고 의미있는 자리라고 생각하지만 아직 젊기 때문에 변화를 주고 싶었고 조금 더 가슴이 뛰는 일을 하고 싶다. 10. 대표직 자리가 부담감이 느껴질 때는 대표인 이유가 있을 것이라고 생각했다.다른 사람들이 보기에 내가 대표직을 맡아도 될 거라고 생각해서 내가 대표직을 맡을 수 있었던 것이라고 위안했다. 못하면 자르겠지. 그냥 최선을 다하자라고 생각했다. 11. 성공한 사람들의 공통점은 겸손함이다.어떤 분이 정말 높은 직위에 있으신데도 하나라도 더 들으려고 노력하시고 끊임없이 메모하고 너무 고맙다며 겸손하게 행동하는 것을 보고 실력과 겸손함을 모두 갖추어야 한다고 생각했다. 하지만 사실 케바케다. 개또라이도 있다. 12. 사람을 움직이는 힘이 중요하다.똑똑한 것은 기본 전제이고 사람을 움직이는 힘이 중요하다. 조금 더 똑똑하고 조금 덜 똑똑한 것은 중요하지 않다. 13. 좋은 질문을 하는 사람이 똑똑한 사람이다.좋은 질문이라는 것은 그 상황과 그 대화 안에서 맥을 잘 짚고 하는 질문이다. 14. 짧고 다양한 경험을 많이 해보자.개발 쪽이라면 경험을 많이 해보는 것이 좋다. 한 분야의 전문가가 되겠다는 것은 실력으로 우리나라에서 끝장내겠다는 뜻이다. 15. 내가 나 자신을 알아야 한다.내가 뭘 잘하는지 알아야 한다. 좋아하지만 실력이 없을 수도 있다. 그건 냉정하게 봐야하는 부분이다. 16. 호기심과 관찰력이 중요하다.개인적으로 아이디어 자체는 별로 중요하지 않다고 생각하고 내가 꽂힐 만큼 그 문제에 공감해야 행동으로 움직이는 것이다. 대부분의 사람들은 그저 “이런 것 하나 있었으면 좋겠다” 라고 생각하고 넘어가지만 어떤 사람들은 그걸 가지고 창업을 한다. 이게 큰 차이다. 항상 호기심이 많아야 한다. 호기심이 있는 사람들이 결국 성공할 확률이 높아진다. 계속 궁금해하고 능동적으로 찾아가라. “AI가 직업을 없앤대”라는 말을 들었을 때 “아 그래?”하는 사람과 “왜? 어느 분야가?”하며 직접 찾아보는 사람이 있다. 17. 리더쉽이란 사람의 마음을 얻는 것이다.실력이 뛰어나서 내 마음대로하는 리더는 좋은 리더가 아니다. 사람들의 마음을 얻고 그 사람들을 이끌어 성과를 내는 것이 좋은 리더다. 마무리사람의 마음을 얻는 사람이라.. 참 어려운 것 같다. 같은 말을 해도 재치있게 하는 사람, 상대방을 기분 좋게 만드는 사람, 뭔가 그냥 든든한 사람, 함께 하고싶은 사람이 되는 것은 타고난 것일까 아니면 노력해서 될 수 있는 것일까.","categories":[{"name":"etc.","slug":"etc","permalink":"https://jess2.github.io/categories/etc/"}],"tags":[{"name":"meetup","slug":"meetup","permalink":"https://jess2.github.io/tags/meetup/"},{"name":"seminar","slug":"seminar","permalink":"https://jess2.github.io/tags/seminar/"},{"name":"talk concert","slug":"talk-concert","permalink":"https://jess2.github.io/tags/talk-concert/"}]},{"title":"[2018. 2] 제 2회 NAVER OpenSource Seminar","slug":"etc/2018-2-제-2회-NAVER-OpenSource-Seminar","date":"2018-02-22T16:35:29.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/02/23/etc/2018-2-제-2회-NAVER-OpenSource-Seminar/","link":"","permalink":"https://jess2.github.io/2018/02/23/etc/2018-2-제-2회-NAVER-OpenSource-Seminar/","excerpt":"","text":"제 2회 NAVER OpenSource Seminar지난 2월 23일에 정자동 NAVER 본사에서 열린 제 2회 NAVER OpenSource Seminar에 참석했다. 이전까지는 밋업에 다녀와서 후기라기 보다는 개인 정리용으로 포스팅을 했었는데, 오늘은 정리를 포함하여 후기까지 적어볼까 한다. 이번 세미나는 대학생과 초급 개발자를 대상으로 개최되었고, 이 이야기들을 대학교 저학년 때 들었다면 얼마나 좋았을까라는 생각과 지금이라도 듣게 되어서 다행이라는 생각을 동시에 하며 열심히 경청했다. 우선, 정자동에 있는 NAVER 본사는 우리 집에서 대중교통 기준으로 30분이면 갈 수 있는 가까운 곳이라 그 동안 갔었던 다른 밋업들보다 더 편하고 빠르게 갈 수 있어서 좋았다. 집과 가까운 덕분에 금방 도착할 수 있었던 NAVER의 세미나 장소인 2층 커넥트 홀 입구에서 네이버 오픈소스 스티커(billboard.js, egjs 등)과 각종 간식을 받았고, 개인적으로 커넥트홀을 포함한 네이버 본사는 건물 내부가 깔끔하고 세련돼서 잠깐 있는 것만으로도 좋았다. 1. 개발자의 흔한 취미 : 오픈소스 개발 - 선데이토즈 권민재님첫 번째 세션은 선데이토즈 권민재님께서 맡아주셨는데 발표를 듣고 나서 오픈소스 개발이 대단한 것이 아니구나라는 것을 깨닫게 되었다. 가장 인상깊었던 것은 흔히 우리는 &lt;오픈소스 개발&gt;이라고 하면 대부분 소스코드 참여하는 것이라고 생각하는데, 소스코드 참여는 오픈소스 개발의 일부분이라는 것이다. 아래는 세션 내용을 정리한 것이다. 1) 오픈소스에 기여하는 방법 오픈소스 참여라는 것이 거창한 것이 아니다. 아주 간단한 오타 수정으로도 오픈소스 참여가 가능하다. 라이브러리나 툴을 사용하다가 원하는 기능이 없거나 문제가 있을 때 직접 해결해서 PR(Pull Request)을 날려보자. 소스코드 참여만이 오픈소스 참여가 아니다. 이슈 보고 및 해결이 오픈소스 참여의 가장 큰 장점이라고 생각한다. 내가 직접 해결하지 않아도 다른 사람들과 같이 이슈에 대해서 해결하면 된다. 완벽한 소프트웨어는 없기 떄문에 퀄리티 유지에 있어서 중요하다. 소스코드를 직접 넣지 않더라도 이슈를 리포팅하는 것 또한 굉장히 중요한 기여다. 이미 보고된 이슈에 대해 코멘트를 달아서 해결책을 제시할 수 있다.(간접적 기여) 번역 : 소스코드가 아닌 문서화에 대한 오픈소스 기여라고 볼 수 있다. 좋은 문서의 내용을 한국어로 번역하여 오픈소스 기여할 수 있다. (단, 문서 번역의 규칙을 숙지하고 이미 진행 중인지에 대한 여부도 확인해야 한다.) 2) 요약 기능/추가 개선 : PR(Pull Request) 보내기. 이슈보고 및 해결 : 발견된 버그나 이슈를 프로젝트에 알리기. 번역 : 문서 번역 직접 운영 : 프로젝트 및 커뮤니티를 직접 운영 2. egjs-view360 개발기(오픈소스화로 기술부채 청산한 이야기) - NAVER 김희재님두 번째 세션은 NAVER FE플랫폼 김희재님께서 맡아주셨는데, 김희재님께서 egjs-view360이라는 오픈소스를 개발하는 과정에서 기술부채가 왜 발생했고 프로젝트에 어떤 영향을 주었으며 오픈소스화로 어떻게 문제상황을 벗어날 수 있었는지에 대해 발표해주셨다. 그 동안 오픈소스로 공개하면 뭐가 좋은지, 오픈소스로 공개할 때 어떤 것을 고려하면 좋은지에 대해 궁금했기 때문에 정말 많은 것을 얻어갈 수 있었던 세션이었다. 본격적인 발표에 들어가기에 앞서 NAVER FE플랫폼에 대해서도 간단하게 소개해주셨는데, FE플랫폼에서는 네이버 FE 기술 지원을 조직하고, 사내 서비스들을 위한 WEB UI 라이브러리를 개발한다고 한다. 또한 경쟁력 있는 컴포넌트는 오픈소스로 공개하는데 예를 들어, egjs, billboard.js, jindo.js가 있다. 아래는 세션 내용을 정리한 것이다. 1) egjs 요구사항 네이티브 WEBGL로 직접 구현 안드로이드 등 모바일 브라우저 호환성 확보 디바이스 모션 컨트롤 2) 기술부채 빠르지만 지저분한 방식으로 일하면 기술부채로 압박받게 된다. 기술부채를 지고 빠른 출시를 할 수 있지만 기술부채를 청산하지 않으면 이자가 계속 커진다. 이자 : 유지보수와 가능 추가를 위해 드는 비용 3) view360에서의 초기 기술부채 테스트코드가 없었다. 하나를 고치면 어디서 부작용이 생길지 알 수가 없어서 기능 추가를 하기가 힘들어졌다. 공감할 수 없는 구조 설계. 남이 공감할 수 업슨 구조라면 미래의 나도 이해할 수 없다. “여기 왜 이렇게 짰지” 코드만 봐도 구조 설계가 납득될 수 있도록 구조를 잘 짜야 한다. 군더더기가 많은 API. 어떤 기능까지 필요하게 될 지 예측하면서 개발 문서화, 설계 문서 4) 처음부터 다시 둘이서 만들기 새로운 시니어 멤버와 다시 만들기 시작했다. WEBGL과 센서신호처리관련 이론을 공부하며 출발선을 맞추고 구조설계를 함께 진행 했다. 오픈소스화 기준에 맞춰 부채청산을 시작했다. 5) 구글의 사례 : 텐서플로 기술을 오픈소스화하면 외부에 공개되기 때문에 문서 작성이나 작업을 체계화하는데 많은 노력을 들인다. 이런 과정에서 팀 전체가 일주일 동안 문서화 작업에 집중한다. 6) 이슈/커밋메세지/문서는 영어로 작성 지나가던 개발자는 웬만하면 영어를 쓴다. 작성하다보면 익숙해진다. 비슷해진 표현을 스택오버플로우나 다른 깃허브 프로젝트 이슈에서 찾아보면서 응용하면 더 쉽다. 7) 커밋메세지 잘 쓰기 이 코드는 왜 이렇지?를 해결한다. 정해진 포멧을 준수하자. 8) Pull Request 단위 줄이기 리뷰를 의미있게 하기 위한 조건 되도록이면 1이슈 1PR이 좋다고 본다. 9) 테스트의 중요성 기능 추가 전후 두려움이 줄어든다. PR을 받을 수 있는 최소한의 준비다. 테스트 없는 오픈소스의 경우 PR을 넣어도 외부 PR을 잘 안받는 경우가 있다. 10) 테스트 작성 구조와 API 설계가 어느정도 안정되고 나서 테스트 작성을 시작한다. 테스트 작성이 힘들면 테스트 가능성 높아지도록 리팩토링 WebGL 렌더링 테스트 방법 적용 디바이스 모션은 테스트 헬퍼 구현 11) PR 단계에서 CI 활용 CI 지속적 통합 PR을 날렸을 때 해당 코드 품질 체크 빌드가 되어야 함 코드컨벤션이 맞아야 함 단위 테스트를 모두 통과해야 함 테스트 커버리지가 감소하지 않아야 함 12) 소개 페이지 프론트엔드의 경우 소개페이지를 꼭 만들어야 한다. 13) 오픈소스화 과정을 통해 얻은 점 포지셔닝 작업을 통해 존재 이유가 생김 라이브러리 품질이 올라감 품질이 떨어질 수 있는 여지를 최대한 줄여놓아서 외부 개바자 참여를 받기 용이함 14) 오픈소스화 과정을 통해 느낀점 타인을 고려하면 할수록 가치가 더해지는 소셜코딩의 힘 나, 미래의 나, 같이 일하는 동료 개발자, 타부서의 개발자/기획자, 사외 개발자/기획자, 내 오픈소스를 이용해 다른 것을 개발하는 개발자, 경쟁 오픈소스의 개발자, 스택오버플로우에서 나와 같은 문제로 질문을 올린 개발자에게 좋다. 3. 오픈소스 생태계 일원으로서의 개발자 - 변정훈 aka Outsider님마지막 세션은 변정훈 aka Outsider님께서 맡아주셨는데, 우리가 오픈소스를 이용하는 것이 아니라, 오픈소스 안에 우리가 있다는 것을 강조해주셨다. 아래는 세션 내용을 정리한 것이다. 1) 개발자는 회사에 속해있고 회사는 오픈소스에 속해있다. 오픈 소스가 없는 개발은 상상하기 어렵다. 우리는 모두 오픈소스 안에 있고 개발자라면 오픈소스 생태계가 더 잘 돌아가도록 만들 책임이 있다. 개발을 하면서 많은 오픈소스를 사용한다. 오픈소스는 개발 시간을 단축시켜준다. 우리가 오픈소스의 도움을 받은 만큼 다시 오픈소스에 기여해야 한다. 4. 마무리이번 네이버 오픈소스 세미나에 참석한 후, 아직 대학생인데도 이미 오픈소스 참여를 활발히 하고 있고, 열정이 넘치는 학생들이 많구나라는 걸 느꼈다. 그리고 세션 발표도 정말 좋은 내용이었지만, 개인적으로 Q&amp;A 시간 때 정말 많은 도움이 된 것 같다. 앞으로 어떤식으로 취업 준비를 해나가야 할지 방향성이 잡힌 것 같다. 너무나 좋은 시간이었고, 또 다음 3회 네이버 세미나에도 참석하고 싶다.","categories":[{"name":"etc.","slug":"etc","permalink":"https://jess2.github.io/categories/etc/"}],"tags":[{"name":"meetup","slug":"meetup","permalink":"https://jess2.github.io/tags/meetup/"},{"name":"seminar","slug":"seminar","permalink":"https://jess2.github.io/tags/seminar/"}]},{"title":"[2018. 2] GDG Campus Korea Meetup","slug":"etc/2018-2-GDG-Campus-Korea-Meetup","date":"2018-02-10T16:19:54.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/02/11/etc/2018-2-GDG-Campus-Korea-Meetup/","link":"","permalink":"https://jess2.github.io/2018/02/11/etc/2018-2-GDG-Campus-Korea-Meetup/","excerpt":"","text":"Google Development Group Campus Korea Meetup“함께 일하고 싶은 개발자 - 나름 큰 회사에서 반년동안 배운 것” - 한재엽님(NAVER)현업에서 배운 ‘개발’이란 것과 ‘코딩’을 보다 좁은 범위로 정의하고 ‘코딩은 무언가를 개발하는 과정의 일부분에 불과하다’라고 느꼈던 부분에 대한 내용을 기반으로 ‘함께 일하고 싶은 개발자’로 나아가기 위한 방향에 대해 이야기할 예정이다. 개발 프로세스 : 이슈 발생 - 스펙 분석 - 일정산정 - 코딩 - 문서화1. 이슈 발생 = 할 일, task 신규, 유지보수, hotfix, 디자인 개편 등 Zenhub을 통한 이슈 관리를 하고 있는데 자신의 일정을 고려하여 할당한다. 이슈를 할당하기 전에 고려해야 할 점은 ‘내가 감당할 수 있는 이슈인가’, ‘현재 진행 중인 이슈와 연관이 있는가’이다. 자신의 실력을 객관적으로 판단할 수 있는 개발자가 함께 일하고 싶은 개발자다. tip. 사수랑 친해져서 사서랑 함께 프로젝트에 들어가는 것이 좋다. 2. 스펙 분석 : 스펙(구현해야 하는 기능)은 생물이다. 스펙 분석을 위한 문서들, 기획서, 피피티 파일 등으로 스펙 분석을 한다. 실제 사례 예시 view 기반 컴포넌트 분리 성능적인 부분 고려 (이미지 lazy loading, 부드러운 애니메이션) 백엔드, 웹 개발자와 인터페이스 협의 필요 UX적인 부분 고려 각 기능 구현 고려 스펙(구현해야 하는 기능)은 ‘메타몽’이다. 스펙 협의 회의에서 많은 커뮤니케이션을 해야 한다. 꼼꼼한 스펙 분석을 할 줄 아는 개발자가 함께 일하고 싶은 개발자다. 3. 일정 산정 : 자신이 assign한 이슈 일정을 산정하는 것 배포 일정 및 예측 가능한 팀 내 리소스 관리를 위해 일정 산정을 해야 한다. 계획 오류 : 작업을 완료하는 데 필요한 시간을 낙관적으로 예상하는 것을 말한다. 90 대 90 법칙 : 기존 프로젝트에 신규 기능이 추가될 경우를 위해 일정을 잘 산정해야 한다. 일정 : 할당된 이슈를 어느 날짜에 시작해서 어느 날짜에 마칠지 따지는 것. 공수 : 이 이슈를 해결 및 완료하는데 하루 n시간 기준 몇 일이 소요되는지 따지는 것 우리는 업무 외에도 정말 많은 일을 하기 때문에 회사에서 실제로 개발에만 사용하는 시간을 따져봐야 한다. (ex. 5시간) 신뢰 가는 일정을 공유할 수 있는 개발자가 함께 일하고 싶은 개발자다. 4. 코딩 가독성이 좋은 코드, 모듈화를 통한 재사용성이 높은 코드가 좋다. 5. 커뮤니케이션 웹프론트엔드는 서버개발자, 마크업개발자, 로그관리자, QA, 디자이너, 기획자들과 커뮤니케이션 해야한다. 개발 용어는 가능하면 사용하지 않는 것이 좋다. 커뮤니케이션할 때는 스크린샷을 첨부하면서 ‘어떤 디바이스에서 어떤 부분이 깨진다.’ 라고 명시해주는 것이 좋다. 코드의 경우에는 하이라이팅 처리하여 메일을 보내는 것이 좋다. 대화가 잘 통하는 개발자가 함께 일하고 싶은 개발자다. 6. 문서화 : 양날의 검, 코드 내 주석. 정돈된 코드와 함께 잘 작성해두자. github 프로젝트의 얼굴. 마크다운 파일을 통해 기본적인 discription을 파악할 수 있다. 정돈된 commit history가 중요하다. 수많은 best practice, commit log가 배포되어 있으니 살펴보자. hit hook을 사용하여 commit message를 관리할 수도 있다. version에 따른 release 기능을 활용할 수 있다. jsdoc을 통한 API document를 관리할 수 있다. .github 파일을 만들어서 문서를 관리할 수 있다. 프로젝트를 시작할 때부터 협의하여 꾸준히 하는 것이 좋다. 문서화를 체계적으로 잘하는 개발자가 함께 일하고 싶은 개발자다. 7. suggestion 혼자보다는 함께 프로젝트 하는 것이 좋다. 프로젝트 하나를 완주하는 것이 좋다. 유지 피드백 받아보는 것이 좋다. 기술 스택에 대한 이유를 생각해보는 것이 좋다. (왜 이 라이브러리를 사용했고, 왜 이 프레임워크를 사용했는지 생각해보자.) 이 기술을 왜 썼는지 항상 면접에서 물어본다. 따라서 고민해보고 공부해는 것만으로도 가치가 있다고 생각한다. 8. QuestionQ. 스터디는 어떤 스터디를 하는지?A. 주로 점심시간에 rx.js, react, angular, vue, webpack 스터디를 진행하고 있다. 9. 발표자료 발표자료 링크","categories":[{"name":"etc.","slug":"etc","permalink":"https://jess2.github.io/categories/etc/"}],"tags":[{"name":"meetup","slug":"meetup","permalink":"https://jess2.github.io/tags/meetup/"},{"name":"seminar","slug":"seminar","permalink":"https://jess2.github.io/tags/seminar/"}]},{"title":"[2018. 1] TypeScript Korea Meetup","slug":"etc/2018-1-TypeScript-Korea-MeetUp","date":"2018-01-18T14:30:53.000Z","updated":"2018-05-29T13:00:00.000Z","comments":true,"path":"2018/01/18/etc/2018-1-TypeScript-Korea-MeetUp/","link":"","permalink":"https://jess2.github.io/2018/01/18/etc/2018-1-TypeScript-Korea-MeetUp/","excerpt":"","text":"TypeScript Korea MeetupTypeScript로부터 얻은 것과 잃은 것 - 손찬욱님(NAVER)1. TypeScript를 사용한 이유 egjs 2.x작업을 해야했고 컴포넌트들 중에 eg.MovableCoord라는 컴포넌트가 있었는데 이것을 개선하고자 하면서 TypeScript를 검토하게 되었다. 줌, 마우스휠, 키보드로도 좌표를 표현하고 싶었고 다형성 및 사용자가 지정하고자 하는 다중의 축들을 제어하기 위해 안정적으로 개발할 수 있는 방법을 찾다가 TypeScript로 결정했다. 기존의 x, y축을 N개의 축을 제어하고 싶었다. 기존과 인터페이스 자체가 달라져서 다시 만들어야 하는 김에 MovableCord를 Axex로 바꿔야겠다고 생각. 안정적으로 개발하는 방법을 찾다가 TypeScript를 생각했다. 다양한 입력 타입은 TypeScript의 inputType인터페이스를 적용하고 각각의 인터페이스들을 기능별로 구현했다. Axes와는 루즈하게 연결할 수 있게 만들었다. 그 결과, 입력 타입도 다양하게 쓸 수 있게 되었고, 축도 늘었다. 2. TypeScript로 얻은것1. 코드 의도가 분명해짐 interface로 설계 의도가 코드에 명확히 보이는데 기존의 JavaScript는 이런 부분이 좀 부족했다. TypeScript는 definition파일까지 자동으로 만들어줬다. 2. 안정성 구현 안 된 요소들이 있을 경우에는 에러로 명확하게 표시해주고, 툴을 쓰면 구현체 형태까지 만들어준다. 편의성과 안정성을 높여준다. 잘못된 값을 넣거나 필수값을 안넣으면 에러를 띄워준다. 자바스크립트에서는 누락될 수 있는 부분들을 잡아주는데 이게 단순하면서도 의외로 오류가 많이 생기는 부분이다. 3. 편의성 Code Assist 제공된다. 코드이동이 가능하다. 사용자 정보를 좌표로 변환해야 하는 경우가 많은데 (data를 변경하는 작업) 데이터가 요건에 따라서 operator를 통해서 변형하게 된다. 데이터 타입이 있어서 코드 어시스트 효과도 볼 수 있고 없는 property에 접근하게 되면 에러를 띄워준다. 4. 데이터 흐름 추적 (안정성) 데이터를 전달하거나 변형하는 경우에 TypeScript가 좋다 5. 결과 코드의 폭넓은 지원 범위 TypeScript는 공식적으로 ES3를 지원해준다. 코드 한 줄만 넣으면 된다. 반면, Babel은 공식적으로 ES3를 지원하지 않는다. babel에서 ES3를 지원하기 위해서는 많은 작업을 해야 한다. 3. TypeScript로 잃은것1. 외부 모듈 사용의 불편함3’rd party 라이브러리 사용시 Axes는 Hommerjs를 사용한다.1import Hammer from 'hammer.js'; 위와 같이 import를 시켜줬지만 Hammer를 가져올 수가 없다. TypeScript에서는 undefined가 뜨고, Babel에서는 Hammer가 뜬다. 하지만 아래와 같이 입력해주면 TypeScript에서도 Hammer, Babel에서도 Hammer가 뜬다.1import * as Hammer from 'hammer.js' 왜 이런 상황이 발생하는가? Hammerjs는 UMD형태로 지원한다. 하지만 ES6 Module로 호출시 CommonJS형태로 인식한다. 그래서 원래는 undefined로 뜨는게 맞는 것이다. 그럼 babel에서는 왜 hammer가 잘 떴을까? babel같은 경우에는 transform-es2015-modules-commonjs를 기본 preset에서 제공하기 때문이다. 다행인 것은 요즘 모듈들은 UMD뿐만 아니라 ES6 Module용도 함께 배포한다는 것이다. 2. 외부 type definition 파일이 완벽하지는 않다. 3’rd party 라이브러리 @types 사용시 CssProps내부 속성이 다 필수여서 재정의하거나 다시 만들어야 하는 번거로움이 있다. 3. 과한 사용은 오히려 독! 과한 사용을 하면 가독성이 떨어진다. 4. 정리1. 좋은 점 (얻은 것) 코드가 명확해지고 별도 주석을 안달아도 명세화가 가능하다 안전성. 구현의 실수를 개발 중 잡아준다. 특히, 데이터 전달과 변환이 많은 곳에서 굉장히 좋다. 편의성. 툴 사용의 극대화 ES3까지 손쉽게 지원 2. 나쁜 점 (잃은 것) 외부 모듈 사용이 불편하다. UMD나 CommonJS형태의 기존 모듈 사용시 번거롭다 외부 type definition파일이 완벽하지는 않다. 과하게 쓰면 오히려 가독성을 떨어뜨린다. (generic)","categories":[{"name":"etc.","slug":"etc","permalink":"https://jess2.github.io/categories/etc/"}],"tags":[{"name":"meetup","slug":"meetup","permalink":"https://jess2.github.io/tags/meetup/"},{"name":"seminar","slug":"seminar","permalink":"https://jess2.github.io/tags/seminar/"}]}]}